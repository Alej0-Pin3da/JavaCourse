
# üìö Teor√≠a Fundamental de Java 8

## TL;DR

Esta secci√≥n cubre los conceptos esenciales para iniciar en Java 8: c√≥mo escribir y ejecutar un programa, la estructura de clases, tipos primitivos y de referencia, control de flujo y buenas pr√°cticas b√°sicas.

## üìã √çndice de Contenidos

- [CONCEPTO 1: El m√©todo main() - Punto de entrada](#-concepto-1-el-m√©todo-main---punto-de-entrada)
- [CONCEPTO 2: Estructura de clases](#Ô∏è-concepto-2--estructura-de-clases)
- [CONCEPTO 3: Salida est√°ndar (System.out)](#Ô∏è-concepto-3--salida-est√°ndar-systemout)
- [CONCEPTO 4: Case Sensitivity](#-concepto-4-case-sensitivity)
- [CONCEPTO 5: Variables est√°ticas vs de instancia](#Ô∏è-concepto-5-variables-est√°ticas-vs-de-instancia)
- [CONCEPTO INTERMEDIO: Interfaces - ¬øQu√© significa implements Runnable?](#-concepto-intermedio-interfaces---qu√©-significa-implements-runnable)
- [CONCEPTO 6: Strings inmutables](#-concepto-6--strings-inmutables)
- [CONCEPTO 7: Estructuras de control](#-concepto-7-estructuras-de-control)
- [CONCEPTO 8: Arrays](#-concepto-8--arrays)
- [CONCEPTO 9: Tipos de datos (primitivos y wrappers)](#-concepto-9--tipos-de-datos-primitivos-y-wrappers)
- [CONCEPTO 10: Reglas para variables, clases y palabras reservadas](#-concepto-10--reglas-para-variables-clases-y-palabras-reservadas)
- [CONCEPTO 11: Tipos de comentarios](#-concepto-11--tipos-de-comentarios)
- [CONCEPTO 12: Paso de par√°metros](#-concepto-12--paso-de-par√°metros)
- [CONCEPTO 13: Peculiaridades y diferencias](#-concepto-13-peculiaridades-y-diferencias)
- [PROYECTO INTEGRADOR: Sistema de Gesti√≥n de Biblioteca](#-proyecto-integrador-sistema-de-gesti√≥n-de-biblioteca)
- [CONCEPTOS AVANZADOS](#conceptos-avanzados)

---

## üìñ TEOR√çA DETALLADA

### üî• **CONCEPTO 1: El m√©todo main() - Punto de entrada**

El m√©todo `main()` es el punto de entrada de cualquier aplicaci√≥n Java ejecutable.

#### Firma obligatoria:
```java
public static void main(String[] args)
```

#### Desglose de componentes:
- **`public`**: Permite que la JVM invoque el m√©todo desde fuera de la clase
- **`static`**: No requiere crear una instancia de la clase para ejecutarse  
- **`void`**: No retorna ning√∫n valor
- **`main`**: Nombre exacto que busca la JVM
- **`String[] args`**: Array que recibe los argumentos de l√≠nea de comandos

    ---

### üèóÔ∏è **CONCEPTO 2: Estructura de clases**

Todo el c√≥digo ejecutable debe estar dentro de clases y m√©todos. Solo una clase `public` por archivo y debe coincidir el nombre del archivo.

#### **Ejemplo m√≠nimo:**
```java
public class HolaMundo {
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}
```

---

## üìö **CONCEPTOS FUNDAMENTALES: CLASE, VARIABLES Y M√âTODOS**

### üèõÔ∏è **¬øQU√â ES UNA CLASE?**

Una **CLASE** es un **MOLDE o PLANTILLA** que define:
- Las **caracter√≠sticas** (variables/atributos) que tendr√°n los objetos
- Los **comportamientos** (m√©todos) que podr√°n realizar los objetos
- Es como un **plano arquitect√≥nico** para construir objetos

#### **üèóÔ∏è Analog√≠a:**
```
Clase = Plantilla/Molde para crear herramientas de ingenier√≠a
Objeto = Herramienta espec√≠fica creada usando esa plantilla

Ejemplo Real:
- Clase Funciones = Molde para crear utilidades de c√°lculo
- Objeto funciones1 = Calculadora espec√≠fica con su propia memoria/estado
- Objeto funciones2 = Otra calculadora independiente
```

#### **üìù Sintaxis de una clase:**
```java
public class NombreClase {
    // Variables (caracter√≠sticas)
    // M√©todos (comportamientos)
    // Constructor (c√≥mo crear objetos)
}
```

#### **üîç Ejemplo pr√°ctico:**
```java
public class ClaseBasica {
    // Constructor
    public ClaseBasica() {
        System.out.println("Objeto ClaseBasica creado");
    }
    
    // M√©todo main
    public static void main(String[] args) {
        ClaseBasica objeto = new ClaseBasica(); // Crear objeto del molde
    }
}
```

---

### üîß **¬øQU√â SON LAS VARIABLES?**

Las **VARIABLES** son **ESPACIOS DE MEMORIA** que almacenan datos. Representan las **CARACTER√çSTICAS** o **PROPIEDADES** de los objetos.

#### **üéØ Tipos de variables en Java:**

##### **1. VARIABLES DE INSTANCIA (Atributos):**
- Pertenecen a cada objeto individual
- Cada objeto tiene su propia copia
- Se declaran dentro de la clase, fuera de m√©todos

```java
// Del archivo Funciones.java - Variables de instancia
public class Funciones implements Runnable {
    String hora, minutos, segundos, ampm;  // Variables de instancia
    Calendar calendario;                    // Variable de instancia
    // Cada objeto Funciones tendr√≠a sus propias copias
}
```

##### **2. VARIABLES LOCALES:**
- Se declaran dentro de m√©todos
- Solo existen mientras se ejecuta el m√©todo
- Deben inicializarse antes de usarse

```java
// Del archivo Funciones.java - Variables locales en el m√©todo redondear
public static double redondear(double numero, int decimales) {
    // 'numero' y 'decimales' son par√°metros (variables locales)
    double factor = Math.pow(10, decimales);  // Variable local
    return Math.round(numero * factor) / factor;
    // 'factor' solo existe dentro de este m√©todo
}
```

##### **3. VARIABLES EST√ÅTICAS (de clase):**
- Pertenecen a la clase, no a objetos individuales
- Una sola copia compartida por todos los objetos
- Se marcan con la palabra `static`

```java
// Del archivo Funciones.java - Variables est√°ticas reales
public class Funciones {
    public static int Tamano;                    // Variable est√°tica
    public static String Ip = "", Equipo = "";  // Variables est√°ticas inicializadas
    public static File Archivo = null;          // Variable est√°tica tipo File
    public static double[][] VpTaps;            // Array est√°tico bidimensional
    
    // Constantes est√°ticas - valores fijos de ingenier√≠a
    public static double C1wrwct = 7.2661 * Math.pow(10, -5);
    public static double C2wrwct = -2.9651 * Math.pow(10, -4);
    
    // Variables boolean est√°ticas para control de estados
    public static boolean advEmbalaje = false;
    public static boolean ULxEstandar = false;
}
```

#### **üí° Caracter√≠sticas principales:**
- **INDEPENDENCIA**: Cada objeto tiene su propia copia (instancia)
- **MEMORIA**: Se almacenan en diferentes √°reas (Heap, Stack, Method Area)
- **ACCESO**: Diferentes formas de acceder seg√∫n el tipo
- **INICIALIZACI√ìN**: En diferentes momentos del ciclo de vida

---

### ‚öôÔ∏è **¬øQU√â SON LOS M√âTODOS?**

Los **M√âTODOS** son **BLOQUES DE C√ìDIGO** que definen los **COMPORTAMIENTOS** o **ACCIONES** que puede realizar un objeto o una clase.

#### **üéØ Componentes de un m√©todo:**
```java
[modificador] [static] tipoRetorno nombreMetodo([par√°metros]) {
    // Cuerpo del m√©todo
    [return valor;]  // Si retorna algo
}
```

#### **üîß Tipos de m√©todos:**

##### **1. M√âTODOS DE INSTANCIA:**
- Operan sobre objetos espec√≠ficos
- Pueden acceder a variables de instancia
- Se llaman: `objeto.nombreMetodo()`

```java
// Del archivo Funciones.java - M√©todos de instancia reales
public class Funciones {
    // Variables de instancia
    String hora, minutos, segundos, ampm;
    Calendar calendario;
    
    // M√©todo de instancia que opera sobre las variables de instancia
    public void calcula() {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        Calendar calendario = new GregorianCalendar();
        int a√±o = calendario.get(Calendar.YEAR);
        int mes = calendario.get(Calendar.MONTH);
        int dia = calendario.get(Calendar.DAY_OF_MONTH);
        DatosEntrada.Fecha=+ dia + "/" + (mes+1) + "/" + a√±o;
        Date fechaHoraActual = new Date();
        calendario.setTime(fechaHoraActual);
        ampm = calendario.get(Calendar.AM_PM)==Calendar.AM?"AM":"PM";
        if(ampm.equals("PM")){
            int h = calendario.get(Calendar.HOUR_OF_DAY)-12;
            hora = h>9?""+h:"0"+h;
        }else{
            hora = calendario.get(Calendar.HOUR_OF_DAY)>9?""+calendario.get(Calendar.HOUR_OF_DAY):"0"+calendario.get(Calendar.HOUR_OF_DAY); 
        }
        minutos = calendario.get(Calendar.MINUTE)>9?""+calendario.get(Calendar.MINUTE):"0"+calendario.get(Calendar.MINUTE);
        segundos = calendario.get(Calendar.SECOND)>9?""+calendario.get(Calendar.SECOND):"0"+calendario.get(Calendar.SECOND);
        if (minutos.equals("15") & segundos.equals("00") || minutos.equals("30") & segundos.equals("00")  || 
            minutos.equals("45") & segundos.equals("00") || minutos.equals("59") & segundos.equals("00")){
            System.out.println("Se ejecuto a los "+minutos+"");
            Consultas.TiempoOracle();
        }
    }
    
    // Otro m√©todo de instancia del sistema real
    public void reloj() {
        // Funci√≥n que calcula la hora y fecha en tiempo real
        // Trabaja con las variables de instancia del objeto
    }
}
```

##### **2. M√âTODOS EST√ÅTICOS:**
- Pertenecen a la clase, no a objetos
- Se marcan con `static`
- Se llaman: `NombreClase.nombreMetodo()`

```java
// Del archivo Funciones.java - M√©todos est√°ticos del mundo real

// Validaci√≥n de entrada - no requiere objeto
public static boolean esNumero(String string) {
    // Determina si un string es n√∫mero o no
    // No necesita crear objeto de Funciones para usarse
}

// Validaci√≥n de datos - IMPLEMENTACI√ìN COMPLETA
public static boolean esNumero(String string) {
    // IMPLEMENTACI√ìN REAL del archivo Funciones.java:
    try {
        Double.parseDouble(string);
    } catch (Exception e) {
        return false;
    }
    return true;
}

// C√°lculo matem√°tico - IMPLEMENTACI√ìN COMPLETA  
public static double redondear(double numero, int decimales) {
    // IMPLEMENTACI√ìN REAL del archivo Funciones.java:
    return Math.round(numero*Math.pow(10,decimales))/Math.pow(10,decimales);
}

// Validaci√≥n de eventos del teclado - IMPLEMENTACI√ìN COMPLETA
public static void SoloNumeros(java.awt.event.KeyEvent evt) {
    // IMPLEMENTACI√ìN REAL del archivo Funciones.java:
    int k = (int) evt.getKeyChar();
    if (k==44) {
        evt.consume();
        JOptionPane.showMessageDialog(null, "Separador con (.)!!!", "Error Datos", JOptionPane.ERROR_MESSAGE);
    }else if (!((k >= 48 && k <= 57) || k < 32 || k ==127 || k==46)) {
        evt.consume();
        JOptionPane.showMessageDialog(null, "No puede ingresar Letras!!!", "Error Datos", JOptionPane.ERROR_MESSAGE);
    }
}

// C√°lculos de ingenier√≠a espec√≠ficos - IMPLEMENTACI√ìN COMPLETA
public static double Calculo_wo(double B) {
    // IMPLEMENTACI√ìN REAL del archivo Funciones.java:
    double Wo= (VariablesEntrada.pla+ VariablesEntrada.plc * B + 
            VariablesEntrada.ple * (Math.pow(B, 2)) + VariablesEntrada.plg * 
            (Math.pow(B, 3)))*2.205 / (1 + VariablesEntrada.plb * B + VariablesEntrada.pld * 
            (Math.pow(B, 2)) + VariablesEntrada.plf * (Math.pow(B, 3)));
    return Wo;
}
```

##### **3. CONSTRUCTOR:**
- M√©todo especial para crear objetos
- Mismo nombre que la clase
- No tiene tipo de retorno

```java
// Del archivo Funciones.java - Constructor impl√≠cito
public class Funciones implements Runnable {
    // Java crea autom√°ticamente un constructor por defecto:
    // public Funciones() {
    //     // Inicializa variables de instancia con valores por defecto
    //     hora = null;
    //     minutos = null;
    //     calendario = null;
    // }
    
    // Constructor personalizado (si fuera necesario):
    public Funciones() {
        // Inicializaci√≥n espec√≠fica para el sistema de transformadores
        calendario = new GregorianCalendar();
        hora = "";
        minutos = "";
        segundos = "";
        ampm = "";
    }
}
```

---

### üèõÔ∏è **RELACI√ìN ENTRE CLASE, VARIABLES Y M√âTODOS**

#### **üìã Estructura conceptual:**

```
CLASE = CONTENEDOR
‚îú‚îÄ‚îÄ VARIABLES = CARACTER√çSTICAS/PROPIEDADES
‚îÇ   ‚îú‚îÄ‚îÄ ¬øQu√© datos almacena?
‚îÇ   ‚îú‚îÄ‚îÄ ¬øQu√© informaci√≥n describe al objeto/clase?
‚îÇ   ‚îî‚îÄ‚îÄ Ejemplo: Ip, Equipo, Tamano, banderas de control
‚îÇ
‚îî‚îÄ‚îÄ M√âTODOS = COMPORTAMIENTOS/ACCIONES  
    ‚îú‚îÄ‚îÄ ¬øQu√© puede hacer la clase?
    ‚îú‚îÄ‚îÄ ¬øC√≥mo procesa los datos?
    ‚îî‚îÄ‚îÄ Ejemplo: redondear(), esNumero(), calcula(), VentanaEntrada()
```

#### **üéØ Ejemplo Real - Clase Funciones del Sistema:**

```java
// Del archivo Funciones.java - Clase utilitaria real de ingenier√≠a
public class Funciones implements Runnable {
    
    // VARIABLES EST√ÅTICAS (Compartidas por toda la aplicaci√≥n):
    public static String Ip = "";           // IP del servidor
    public static String Equipo = "";       // Nombre del equipo
    public static int Tamano;                // Tama√±o de elementos
    public static File Archivo = null;      // Archivo de trabajo actual
    
    // Variables de control del sistema
    public static int bandera, bandera1, bandera2; // Estados de proceso
    public static boolean advEmbalaje = false;      // Advertencia de embalaje
    public static double[][] VpTaps;               // Datos de taps de voltaje
    
    // Constantes de ingenier√≠a (f√≥rmulas espec√≠ficas)
    public static double C1wrwct = 7.2661 * Math.pow(10, -5);
    public static double C2wrwct = -2.9651 * Math.pow(10, -4);
    
    // VARIABLES DE INSTANCIA (Espec√≠ficas de cada objeto):
    String hora, minutos, segundos, ampm;    // Tiempo actual
    Calendar calendario;                     // Calendario del objeto
    
    // M√âTODOS EST√ÅTICOS (Utilidades que no requieren objetos):
    
    // Validaci√≥n de datos - IMPLEMENTACI√ìN COMPLETA
    public static boolean esNumero(String string) {
        try {
            Double.parseDouble(string);
        } catch (Exception e) {
            return false;
        }
        return true;
    }
    
    // C√°lculos matem√°ticos de ingenier√≠a - IMPLEMENTACI√ìN COMPLETA
    public static double redondear(double numero, int decimales) {
        return Math.round(numero*Math.pow(10,decimales))/Math.pow(10,decimales);
    }
    
    public static double Calculo_wo(double B) {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        double Wo= (VariablesEntrada.pla+ VariablesEntrada.plc * B + 
                VariablesEntrada.ple * (Math.pow(B, 2)) + VariablesEntrada.plg * 
                (Math.pow(B, 3)))*2.205 / (1 + VariablesEntrada.plb * B + VariablesEntrada.pld * 
                (Math.pow(B, 2)) + VariablesEntrada.plf * (Math.pow(B, 3)));
        return Wo;
    }
    
    // Gesti√≥n de interfaz de usuario - IMPLEMENTACI√ìN COMPLETA
    public static void VentanaEntrada(boolean band) {
        try{
            VariablesEntrada.VEntrada=0;
            if (Funciones.entrada==null) {
                Funciones.entrada=new Entrada();
                Funciones.AbrirVentanas(Funciones.entrada,true,band,true);
                bandera=1;            
                DatosEntrada.InicializarVariables();
            }else{
                Funciones.AbrirVentanas(Funciones.entrada,false,band,true);
            }     
        }catch(HeadlessException ex){}
    }
    
    public static void SoloNumeros(java.awt.event.KeyEvent evt) {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        int k = (int) evt.getKeyChar();
        if (k==44) {
            evt.consume();
            JOptionPane.showMessageDialog(null, "Separador con (.)!!!", "Error Datos", JOptionPane.ERROR_MESSAGE);
        }else if (!((k >= 48 && k <= 57) || k < 32 || k ==127 || k==46)) {
            evt.consume();
            JOptionPane.showMessageDialog(null, "No puede ingresar Letras!!!", "Error Datos", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    // M√âTODOS DE INSTANCIA (Operan sobre datos del objeto):
    public void calcula() {
        // Calcula hora y fecha usando 'calendario' (variable de instancia)
        calendario = new GregorianCalendar();
        // Actualiza hora, minutos, segundos, ampm
    }
    
    public void reloj() {
        // Funci√≥n de reloj en tiempo real
        // Usa las variables de instancia para mantener el tiempo
    }
}
```

#### **üíª Uso Real en el Sistema:**

```java
// Uso de m√©todos est√°ticos (sin crear objetos):
public class SistemaTransformadores {
    public static void main(String[] args) {
        // Validar entrada de usuario
        String entrada = "123.45";
        if (Funciones.esNumero(entrada)) {
            double valor = Double.parseDouble(entrada);
            
            // Redondear para mostrar en interfaz
            double valorRedondeado = Funciones.redondear(valor, 2);
            System.out.println("Valor: " + valorRedondeado);
            
            // Calcular p√©rdidas en transformador
            double perdidas = Funciones.Calculo_wo(1.7); // 1.7 KiloGauss
            System.out.println("P√©rdidas: " + perdidas + " W/kg");
            
            // Abrir ventana de entrada
            Funciones.VentanaEntrada(true);
        }
        
        // Uso de m√©todos de instancia (requiere objeto):
        Funciones reloj = new Funciones();
        reloj.calcula();  // Calcula tiempo actual
        reloj.reloj();    // Inicia reloj en tiempo real
    }
}
```

#### **üéì Ejemplo Pr√°ctico - Clase Funciones del Sistema Real:**

```java
public class Funciones implements Runnable {
    // VARIABLES DE INSTANCIA: Caracter√≠sticas espec√≠ficas de cada instancia
    String hora, minutos, segundos, ampm;  // Estado del reloj
    Calendar calendario;                    // Calendario espec√≠fico del objeto
    
    // VARIABLES DE CLASE (STATIC): Compartidas por todos los objetos
    public static String Ip = "";           // IP del servidor
    public static String Equipo = "";       // Equipo actual
    public static int Tamano;               // Tama√±o est√°ndar
    public static boolean advEmbalaje = false;  // Control global
    
    // CONSTRUCTOR: Inicializa nuevas instancias
    public Funciones() {
        calendario = new GregorianCalendar();  // Inicializar calendario
        calcula();                             // Calcular hora inicial
    }
    
    // M√âTODOS DE INSTANCIA: Operan sobre datos espec√≠ficos del objeto
    public void calcula() {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        Calendar calendario = new GregorianCalendar();
        int a√±o = calendario.get(Calendar.YEAR);
        int mes = calendario.get(Calendar.MONTH);
        int dia = calendario.get(Calendar.DAY_OF_MONTH);
        DatosEntrada.Fecha=+ dia + "/" + (mes+1) + "/" + a√±o;
        Date fechaHoraActual = new Date();
        calendario.setTime(fechaHoraActual);
        ampm = calendario.get(Calendar.AM_PM)==Calendar.AM?"AM":"PM";
        if(ampm.equals("PM")){
            int h = calendario.get(Calendar.HOUR_OF_DAY)-12;
            hora = h>9?""+h:"0"+h;
        }else{
            hora = calendario.get(Calendar.HOUR_OF_DAY)>9?""+calendario.get(Calendar.HOUR_OF_DAY):"0"+calendario.get(Calendar.HOUR_OF_DAY); 
        }
        minutos = calendario.get(Calendar.MINUTE)>9?""+calendario.get(Calendar.MINUTE):"0"+calendario.get(Calendar.MINUTE);
        segundos = calendario.get(Calendar.SECOND)>9?""+calendario.get(Calendar.SECOND):"0"+calendario.get(Calendar.SECOND);
        if (minutos.equals("15") & segundos.equals("00") || minutos.equals("30") & segundos.equals("00")  || 
            minutos.equals("45") & segundos.equals("00") || minutos.equals("59") & segundos.equals("00")){
            System.out.println("Se ejecuto a los "+minutos+"");
            Consultas.TiempoOracle();
        }
    }
    
    public void reloj() {
        // Funci√≥n de reloj que usa los datos de esta instancia
        SwingUtilities.invokeLater(this);  // Actualizaci√≥n de interfaz
    }
    
    // M√âTODOS EST√ÅTICOS: Utilidades independientes, no necesitan objetos
    public static double redondear(double numero, int decimales) {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        return Math.round(numero*Math.pow(10,decimales))/Math.pow(10,decimales);
    }
    
    public static boolean esNumero(String string) {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        try {
            Double.parseDouble(string);
        } catch (Exception e) {
            return false;
        }
        return true;
    }
    
    public static void VentanaEntrada(boolean band) {
        // IMPLEMENTACI√ìN COMPLETA del archivo Funciones.java:
        try{
            VariablesEntrada.VEntrada=0;
            if (Funciones.entrada==null) {
                Funciones.entrada=new Entrada();
                Funciones.AbrirVentanas(Funciones.entrada,true,band,true);
                bandera=1;            
                DatosEntrada.InicializarVariables();
            }else{
                Funciones.AbrirVentanas(Funciones.entrada,false,band,true);
            }     
        }catch(HeadlessException ex){}
    }
            v.setVisible(true);
        }
    }
}
```

#### **üíª Uso Real en el Sistema:**
```java
public class SistemaTransformadores {
    public static void main(String[] args) {
        // USAR M√âTODOS EST√ÅTICOS (sin crear objetos):
        // Validar entrada de usuario
        String entrada = "123.45";
        if (Funciones.esNumero(entrada)) {  // M√©todo est√°tico
            double valor = Double.parseDouble(entrada);
            
            // Redondear resultado
            double resultado = Funciones.redondear(valor, 2);  // M√©todo est√°tico
            System.out.println("Valor procesado: " + resultado);
            
            // Abrir ventana del sistema
            Funciones.VentanaEntrada(true);  // M√©todo est√°tico
        }
        
        // CREAR Y USAR OBJETOS (instancias):
        Funciones reloj1 = new Funciones();     // Reloj del panel principal
        Funciones reloj2 = new Funciones();     // Reloj del panel de reportes
        
        // Cada objeto mantiene su propia hora
        reloj1.calcula();  // Calcula hora en reloj1
        reloj2.calcula();  // Calcula hora en reloj2 (independiente)
        
        // Cada objeto tiene su propio hilo de ejecuci√≥n
        new Thread(reloj1).start();  // Inicia reloj1
        new Thread(reloj2).start();  // Inicia reloj2
        
        // Variables est√°ticas son compartidas:
        System.out.println("IP del sistema: " + Funciones.Ip);      // Mismo para todos
        System.out.println("Equipo: " + Funciones.Equipo);          // Mismo para todos
    }
}
```

---

### üí° **PUNTOS CLAVE PARA RECORDAR**

#### **üîπ CLASE:**
- Es el **MOLDE/PLANTILLA**
- Define **QU√â** caracter√≠sticas y comportamientos tendr√°n los objetos
- Se escribe **UNA VEZ**, se usa **MUCHAS VECES**

#### **üîπ VARIABLES:**
- Almacenan **DATOS/INFORMACI√ìN**
- Representan el **ESTADO** del objeto
- Responden a: **"¬øQu√© informaci√≥n tiene?"**

#### **üîπ M√âTODOS:**
- Definen **ACCIONES/COMPORTAMIENTOS**
- Operan sobre los datos (variables)
- Responden a: **"¬øQu√© puede hacer?"**

#### **üéØ REGLA DE ORO:**
```
CLASE = VARIABLES (datos) + M√âTODOS (acciones)
OBJETO = Una instancia espec√≠fica de la clase con valores concretos
```

**Esta es la base fundamental de la Programaci√≥n Orientada a Objetos en Java.**

---

## üîç **AN√ÅLISIS PR√ÅCTICO: M√âTODO REAL DE FUNCIONES.JAVA**

### **üßÆ Ejemplo del mundo real: M√©todo `redondear()`**

Vamos a analizar un m√©todo real del archivo `Funciones.java` para ver c√≥mo se aplican los conceptos fundamentales en la pr√°ctica:

```java
/**
 * <B>Titulo:</B>redondear<br>.
 * <B>Descripci√≥n:</B>Funcion paa redondear un numero<br>
 * @param numero
 * @param decimales
 * @return 
 * @since 1.0 Feb 10, 2014.
 */
public static double redondear(double numero, int decimales) {
    // C√°lculo del factor de redondeo
    double factor = Math.pow(10, decimales);
    
    // Aplicar redondeo matem√°tico
    return Math.round(numero * factor) / factor;
}
```

#### **üèóÔ∏è AN√ÅLISIS DETALLADO:**

##### **üìö CLASE: `Funciones`**
- **Prop√≥sito**: Contenedor de utilidades matem√°ticas y funciones auxiliares
- **Tipo**: Clase utilitaria (contiene m√©todos est√°ticos)
- **Ubicaci√≥n**: `package modelo;`
- **Responsabilidad**: Proporcionar funciones matem√°ticas reutilizables

##### **üîß VARIABLES en el m√©todo:**

**1. PAR√ÅMETROS (Variables de entrada):**
```java
double numero    // N√∫mero que se va a redondear
int decimales    // Cantidad de decimales deseados
```

**2. VARIABLES LOCALES:**
```java
double factor = Math.pow(10, decimales);  // Variable local calculada
```

**3. VARIABLE DE RETORNO:**
```java
return Math.round(numero * factor) / factor;  // Resultado calculado
```

##### **‚öôÔ∏è M√âTODO: `redondear()`**

**Componentes del m√©todo:**
- **`public`**: Modificador de acceso - puede llamarse desde cualquier lugar
- **`static`**: M√©todo de clase - no requiere crear objeto de `Funciones`
- **`double`**: Tipo de retorno - devuelve un n√∫mero decimal
- **`redondear`**: Nombre descriptivo del comportamiento
- **`(double numero, int decimales)`**: Par√°metros de entrada

#### **üíª EJEMPLOS DE USO EN LA PR√ÅCTICA:**

```java
// Llamadas al m√©todo desde otras partes del c√≥digo
public class EjemplosDeUso {
    public static void main(String[] args) {
        // Redondear a 2 decimales
        double precio = 15.6789;
        double precioRedondeado = Funciones.redondear(precio, 2);
        System.out.println("Precio: $" + precioRedondeado); // Precio: $15.68
        
        // Redondear a 1 decimal
        double temperatura = 23.456;
        double tempRedondeada = Funciones.redondear(temperatura, 1);
        System.out.println("Temperatura: " + tempRedondeada + "¬∞C"); // Temperatura: 23.5¬∞C
        
        // Redondear a entero (0 decimales)
        double distancia = 127.89;
        double distanciaEntera = Funciones.redondear(distancia, 0);
        System.out.println("Distancia: " + distanciaEntera + " km"); // Distancia: 128.0 km
    }
}
```

#### **üéØ CONCEPTOS FUNDAMENTALES APLICADOS:**

##### **üèõÔ∏è CLASE como contenedor:**
```java
public class Funciones {
    // Contiene m√∫ltiples m√©todos utilitarios
    public static double redondear(double numero, int decimales) { ... }
    public static boolean esNumero(String string) { ... }
    public static double Calculo_wo(double B) { ... }
    // ... m√°s m√©todos
}
```

##### **üîß VARIABLES con diferentes alcances:**
```java
public class Funciones {
    // VARIABLES EST√ÅTICAS (de clase) - compartidas
    public static int Tamano;
    public static String Ip = "";
    
    // M√âTODO con variables locales - IMPLEMENTACI√ìN COMPLETA
    public static double redondear(double numero, int decimales) {
        // PAR√ÅMETROS - reciben valores del exterior
        // numero y decimales son variables locales
        
        // IMPLEMENTACI√ìN REAL del archivo Funciones.java:
        return Math.round(numero*Math.pow(10,decimales))/Math.pow(10,decimales);
        
        /* EXPLICACI√ìN DE LA F√ìRMULA:
         * 1. Math.pow(10, decimales) crea el factor de multiplicaci√≥n
         *    Ejemplo: para 2 decimales = 10^2 = 100
         * 2. numero * factor desplaza decimales a la izquierda 
         *    Ejemplo: 3.14159 * 100 = 314.159
         * 3. Math.round() redondea al entero m√°s cercano
         *    Ejemplo: Math.round(314.159) = 314
         * 4. Dividir por factor regresa los decimales a su lugar
         *    Ejemplo: 314 / 100 = 3.14
         */
        
        // VARIABLE DE RETORNO - resultado del m√©todo
        return Math.round(numero * factor) / factor;
    }
}
```

##### **‚öôÔ∏è M√âTODO como comportamiento:**
```java
// El m√©todo define UNA ACCI√ìN ESPEC√çFICA: "redondear n√∫meros"
public static double redondear(double numero, int decimales) {
    // ENTRADA: Recibe datos (n√∫mero y decimales)
    // PROCESAMIENTO: Aplica l√≥gica matem√°tica
    // SALIDA: Devuelve resultado procesado
}
```

#### **üìä FLUJO DE EJECUCI√ìN PASO A PASO:**

```java
// 1. LLAMADA AL M√âTODO
double resultado = Funciones.redondear(15.6789, 2);

// 2. ASIGNACI√ìN DE PAR√ÅMETROS
// numero = 15.6789
// decimales = 2

// 3. CREACI√ìN DE VARIABLE LOCAL
// factor = Math.pow(10, 2) = 100.0

// 4. C√ÅLCULO DEL RESULTADO
// numero * factor = 15.6789 * 100 = 1567.89
// Math.round(1567.89) = 1568
// 1568 / factor = 1568 / 100 = 15.68

// 5. RETORNO DEL RESULTADO
// return 15.68
```

#### **üèÜ CARACTER√çSTICAS DEL DISE√ëO:**

##### **‚úÖ Buenas pr√°cticas aplicadas:**
- **M√©todo est√°tico**: No necesita instancia, es una utilidad pura
- **Par√°metros claros**: `numero` y `decimales` son autodescriptivos  
- **Nombre descriptivo**: `redondear` indica exactamente qu√© hace
- **Tipo de retorno apropiado**: `double` para mantener precisi√≥n
- **Documentaci√≥n**: JavaDoc completo con prop√≥sito y par√°metros

##### **üéØ Uso en el contexto real:**
```java
// En la aplicaci√≥n real se usa para:
// - Redondear c√°lculos de ingenier√≠a
// - Formatear precios y costos
// - Ajustar medidas y dimensiones
// - Presentar resultados con precisi√≥n controlada

// Ejemplo del contexto de transformadores:
double perdidas = 1567.8934;  // P√©rdidas calculadas
double perdidasRedondeadas = Funciones.redondear(perdidas, 2);
// Resultado: 1567.89 W (m√°s legible para reportes)
```

#### **üí° LECCIONES CLAVE:**

1. **CLASE**: `Funciones` act√∫a como biblioteca de utilidades
2. **VARIABLES**: Diferentes tipos con diferentes alcances y prop√≥sitos
3. **M√âTODO**: Encapsula una funcionalidad espec√≠fica y reutilizable
4. **STATIC**: Permite usar la funcionalidad sin crear objetos
5. **PAR√ÅMETROS**: Entrada de datos para personalizar el comportamiento
6. **RETORNO**: Salida procesada para usar en otros lugares

**Este ejemplo demuestra c√≥mo los conceptos te√≥ricos se aplican en c√≥digo real de producci√≥n.**

---

### üñ•Ô∏è **CONCEPTO 3: Salida est√°ndar (System.out)**

#### **¬øQu√© es System.out?**
`System.out` es un objeto de tipo `PrintStream` que representa la **salida est√°ndar** del programa, t√≠picamente la consola o terminal. Es parte de la clase `System` en el paquete `java.lang` y es la forma m√°s com√∫n de mostrar informaci√≥n al usuario en aplicaciones de consola.

#### **1. M√âTODOS PRINCIPALES**

##### **1.1 println() - Imprime con salto de l√≠nea**
```java
public class EjemplosPrintln {
    public static void main(String[] args) {
        System.out.println("Primera l√≠nea");
        System.out.println("Segunda l√≠nea");
        System.out.println(42);
        System.out.println(true);
        System.out.println(3.14159);
        
        // Salida:
        // Primera l√≠nea
        // Segunda l√≠nea
        // 42
        // true
        // 3.14159
    }
}
```

##### **1.2 print() - Imprime sin salto de l√≠nea**
```java
public class EjemplosPrint {
    public static void main(String[] args) {
        System.out.print("Hola ");
        System.out.print("Mundo ");
        System.out.print("desde ");
        System.out.print("Java");
        
        // Salida: Hola Mundo desde Java
    }
}
```

##### **1.3 printf() - Impresi√≥n con formato**
```java
public class EjemplosPrintf {
    public static void main(String[] args) {
        String nombre = "Juan";
        int edad = 25;
        double altura = 1.75;
        boolean estudiante = true;
        
        System.out.printf("Nombre: %s%n", nombre);
        System.out.printf("Edad: %d a√±os%n", edad);
        System.out.printf("Altura: %.2f metros%n", altura);
        System.out.printf("¬øEs estudiante? %b%n", estudiante);
        
        // Formato complejo en una l√≠nea
        System.out.printf("%-10s | %3d | %6.2f | %-10s%n", 
                         nombre, edad, altura, estudiante);
        
        // Salida:
        // Nombre: Juan
        // Edad: 25 a√±os
        // Altura: 1.75 metros
        // ¬øEs estudiante? true
        // Juan       |  25 |   1.75 | true      
    }
}
```

#### **2. ESPECIFICADORES DE FORMATO**

| Especificador | Tipo | Descripci√≥n | Ejemplo |
|---------------|------|-------------|---------|
| `%s` | String | Cadena de texto | `"Hola"` |
| `%d` | int/long | Entero decimal | `123` |
| `%o` | int/long | Entero octal | `173` (123 en octal) |
| `%x` / `%X` | int/long | Entero hexadecimal | `7b` / `7B` |
| `%f` | float/double | Punto flotante | `123.456000` |
| `%.2f` | float/double | Flotante con 2 decimales | `123.46` |
| `%e` / `%E` | float/double | Notaci√≥n cient√≠fica | `1.234560e+02` |
| `%c` | char/int | Car√°cter | `'A'` |
| `%b` | boolean | Booleano | `true` / `false` |
| `%n` | - | Nueva l√≠nea (independiente del SO) | Salto de l√≠nea |
| `%%` | - | S√≠mbolo de porcentaje literal | `%` |

#### **3. MODIFICADORES DE FORMATO**

##### **3.1 Ancho de campo y alineaci√≥n:**
```java
public class ModificadoresFormato {
    public static void main(String[] args) {
        String producto = "Laptop";
        int precio = 1500;
        
        // Alineaci√≥n a la derecha (por defecto)
        System.out.printf("%10s: $%5d%n", producto, precio);
        
        // Alineaci√≥n a la izquierda
        System.out.printf("%-10s: $%-5d%n", producto, precio);
        
        // Rellenar con ceros
        System.out.printf("%010d%n", precio);
        
        // Mostrar signo siempre
        System.out.printf("%+d%n", precio);
        
        // Salida:
        //     Laptop: $ 1500
        // Laptop    : $1500 
        // 0000001500
        // +1500
    }
}
```

#### **4. DIFERENCIAS IMPORTANTES**

##### **4.1 print() vs println():**
```java
public class DiferenciasPrint {
    public static void main(String[] args) {
        // Con println() cada salida va en nueva l√≠nea
        System.out.println("L√≠nea 1");
        System.out.println("L√≠nea 2");
        System.out.println("L√≠nea 3");
        
        System.out.println("--- Separador ---");
        
        // Con print() todo va en la misma l√≠nea
        System.out.print("Palabra1 ");
        System.out.print("Palabra2 ");
        System.out.print("Palabra3");
        System.out.println(); // Salto manual
        
        // Salida:
        // L√≠nea 1
        // L√≠nea 2
        // L√≠nea 3
        // --- Separador ---
        // Palabra1 Palabra2 Palabra3
    }
}
```

##### **4.2 printf() vs println() para n√∫meros:**
```java
public class FormatoNumeros {
    public static void main(String[] args) {
        double numero = 3.141592653589793;
        
        System.out.println("Con println():");
        System.out.println(numero); // 3.141592653589793
        
        System.out.println("Con printf():");
        System.out.printf("2 decimales: %.2f%n", numero);  // 3.14
        System.out.printf("4 decimales: %.4f%n", numero);  // 3.1416
        System.out.printf("Notaci√≥n cient√≠fica: %.2e%n", numero); // 3.14e+00
        
        // Para precios
        double precio = 1234.5;
        System.out.printf("Precio: $%,.2f%n", precio); // $1,234.50
    }
}
```

#### **5. BUENAS PR√ÅCTICAS**

##### **5.1 Uso de %n en lugar de \n:**
```java
// ‚ùå Dependiente del sistema operativo
System.out.printf("Primera l√≠nea\nSegunda l√≠nea");

// ‚úÖ Independiente del sistema operativo
System.out.printf("Primera l√≠nea%nSegunda l√≠nea");
```

##### **5.2 Validaci√≥n de argumentos:**
```java
public class ValidacionFormato {
    public static void main(String[] args) {
        String nombre = null;
        Integer edad = null;
        
        // ‚ùå Puede causar excepci√≥n
        // System.out.printf("Nombre: %s, Edad: %d%n", nombre, edad);
        
        // ‚úÖ Validaci√≥n previa
        System.out.printf("Nombre: %s, Edad: %s%n", 
                         nombre != null ? nombre : "N/A",
                         edad != null ? edad.toString() : "N/A");
    }
}
```

##### **5.3 Constantes para formatos complejos:**
```java
public class ConstantesFormato {
    private static final String FORMATO_PRODUCTO = "%-15s | $%8.2f | %5d unidades%n";
    private static final String FORMATO_FECHA = "%02d/%02d/%04d %02d:%02d%n";
    
    public static void main(String[] args) {
        System.out.printf(FORMATO_PRODUCTO, "Laptop", 1299.99, 5);
        System.out.printf(FORMATO_PRODUCTO, "Mouse", 29.99, 25);
        
        System.out.printf(FORMATO_FECHA, 15, 8, 2024, 14, 30);
    }
}
```

### üéØ **Ejercicios pr√°cticos para System.out**

#### **Ejercicio 1: Men√∫ de restaurante**
```java
public class EjercicioMenu {
    public static void main(String[] args) {
        // Crear un men√∫ usando System.out.printf con formato de tabla
        System.out.printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó%n");
        System.out.printf("‚ïë           RESTAURANTE JAVA CAF√â          ‚ïë%n");
        System.out.printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£%n");
        System.out.printf("‚ïë %-25s | %8s ‚ïë%n", "PLATO", "PRECIO");
        System.out.printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£%n");
        System.out.printf("‚ïë %-25s | $%7.2f ‚ïë%n", "Hamburguesa Cl√°sica", 12.99);
        System.out.printf("‚ïë %-25s | $%7.2f ‚ïë%n", "Pizza Margarita", 15.50);
        System.out.printf("‚ïë %-25s | $%7.2f ‚ïë%n", "Ensalada C√©sar", 9.25);
        System.out.printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù%n");
        
        // Agregar resumen con totales
        double subtotal = 37.74;
        double impuesto = subtotal * 0.15;
        double total = subtotal + impuesto;
        
        System.out.printf("%n--- RESUMEN DE CUENTA ---%n");
        System.out.printf("Subtotal: $%6.2f%n", subtotal);
        System.out.printf("Impuesto: $%6.2f%n", impuesto);
        System.out.printf("Total:    $%6.2f%n", total);
    }
}
```

#### **Ejercicio 2: Debug con System.err**
```java
public class EjercicioDebug {
    public static void main(String[] args) {
        String usuario = "admin";
        String password = "123456";
        
        System.out.println("=== Sistema de Login ===");
        System.out.printf("Usuario: %s%n", usuario);
        
        // Simular validaci√≥n
        if (password.length() < 8) {
            System.err.printf("ERROR: Contrase√±a muy corta. M√≠nimo 8 caracteres, actual: %d%n", 
                            password.length());
            System.err.println("NIVEL: CR√çTICO - Acceso denegado");
            return;
        }
        
        System.out.println("‚úÖ Login exitoso");
        System.out.printf("Bienvenido %s, hora de acceso: %tT%n", usuario, 
                         java.time.LocalTime.now());
    }
}
```

#### **Ejercicio 3: Calculadora con formato**
```java
public class EjercicioCalculadora {
    public static void main(String[] args) {
        double num1 = 15.7;
        double num2 = 4.3;
        
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë            CALCULADORA               ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        System.out.printf("%nOperandos: %.2f y %.2f%n%n", num1, num2);
        
        // Realizar operaciones y mostrar con formato
        System.out.printf("Suma:          %6.2f + %6.2f = %8.2f%n", num1, num2, num1 + num2);
        System.out.printf("Resta:         %6.2f - %6.2f = %8.2f%n", num1, num2, num1 - num2);
        System.out.printf("Multiplicaci√≥n:%6.2f √ó %6.2f = %8.2f%n", num1, num2, num1 * num2);
        System.out.printf("Divisi√≥n:      %6.2f √∑ %6.2f = %8.2f%n", num1, num2, num1 / num2);
        System.out.printf("M√≥dulo:        %6.2f %% %6.2f = %8.2f%n", num1, num2, num1 % num2);
        
        // Mostrar en notaci√≥n cient√≠fica
        double resultado = num1 * num2;
        System.out.printf("%nEn notaci√≥n cient√≠fica: %e%n", resultado);
    }
}
```

---

### üìù **CONCEPTO 4: Case Sensitivity**

Java es un lenguaje **case-sensitive**, lo que significa que distingue entre may√∫sculas y min√∫sculas en **todos** los identificadores. Esta caracter√≠stica afecta nombres de variables, m√©todos, clases, palabras clave y literales.

#### **¬øQu√© significa Case Sensitivity?**

En Java, cada car√°cter en may√∫scula se considera diferente de su equivalente en min√∫scula. Esto significa que `Variable`, `variable`, `VARIABLE` y `VaRiAbLe` son cuatro identificadores completamente distintos.

#### **Ejemplos pr√°cticos:**

##### **1. Variables:**
```java
// Todas estas son VARIABLES DIFERENTES:
int edad = 25;
int Edad = 30;
int EDAD = 35;
int EdAd = 40;

System.out.println(edad);  // 25
System.out.println(Edad);  // 30
System.out.println(EDAD);  // 35
System.out.println(EdAd);  // 40
```
 
 - Tabla de promoci√≥n autom√°tica en operaciones:
     - byte, short, char ‚Üí int
     - int + long ‚Üí long
     - int + float ‚Üí float
     - float + double ‚Üí double

#### **Conversiones de tipos (Casting)**

##### **Conversiones impl√≠citas (seguras):**
```java
// Widening conversion - sin p√©rdida de datos
byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double
char ‚Üí int

public class ConversionesImplicitas {
    public static void main(String[] args) {
        byte byteVal = 100;
        short shortVal = byteVal;  // byte ‚Üí short (autom√°tico)
        int intVal = shortVal;     // short ‚Üí int (autom√°tico)
        long longVal = intVal;     // int ‚Üí long (autom√°tico)
        float floatVal = longVal;  // long ‚Üí float (autom√°tico)
        double doubleVal = floatVal; // float ‚Üí double (autom√°tico)
        
        System.out.println("Cadena de conversiones: " + doubleVal); // 100.0
    }
}
```

##### **Conversiones expl√≠citas (potencialmente peligrosas):**
```java
public class ConversionesExplicitas {
    public static void main(String[] args) {
        // Narrowing conversion - puede haber p√©rdida de datos
        
        // 1. P√©rdida de precisi√≥n:
        double pi = 3.141592653589793;
        float piFloat = (float) pi;    // Pierde precisi√≥n
        int piInt = (int) pi;          // Trunca decimales: 3
        
        System.out.println("double: " + pi);        // 3.141592653589793
        System.out.println("float:  " + piFloat);   // 3.1415927 (menos precisi√≥n)
        System.out.println("int:    " + piInt);     // 3 (sin decimales)
        
        // 2. Overflow/Underflow:
        long numeroGrande = 3000000000L;           // Mayor que int MAX
        int overflow = (int) numeroGrande;         // Resultado impredecible por overflow
        
        System.out.println("Original: " + numeroGrande);  // 3000000000
        System.out.println("Con overflow: " + overflow);  // -1294967296 (valor "envuelto")
        
        // 3. Conversi√≥n entre tipos incompatibles:
        int numero = 65;
        char caracter = (char) numero;             // int ‚Üí char (c√≥digo ASCII)
        System.out.println("N√∫mero 65 como char: " + caracter); // 'A'
    }
}
```

#### **Verificaci√≥n de tipos en compilaci√≥n vs ejecuci√≥n**

##### **Lo que Java verifica en COMPILACI√ìN:**
```java
public class VerificacionCompilacion {
    public static void main(String[] args) {
        // Verificaciones que Java hace ANTES de ejecutar:
        
        String texto = "Hola";
        // int numero = texto;           // ‚ùå ERROR: incompatibilidad de tipos
        // texto.metodoInexistente();    // ‚ùå ERROR: m√©todo no existe
        // int[] array = new String[5];  // ‚ùå ERROR: tipo de array incompatible
        
        // Verificaci√≥n de par√°metros de m√©todos:
        // procesarNumero(texto);        // ‚ùå ERROR: String no es int
        procesarNumero(42);              // ‚úÖ OK: int es compatible
    }
    
    public static void procesarNumero(int numero) {
        System.out.println("Procesando: " + numero);
    }
}
```

##### **Lo que se verifica en EJECUCI√ìN:**
```java
public class VerificacionEjecucion {
    public static void main(String[] args) {
        // Cosas que solo se pueden verificar ejecutando:
        
        // 1. Divisi√≥n por cero:
        int a = 10;
        int b = 0;
        // int resultado = a / b; // Compila OK, pero RuntimeException en ejecuci√≥n
        
        // 2. Acceso a arrays:
        int[] numeros = {1, 2, 3};
        // int valor = numeros[5]; // Compila OK, pero IndexOutOfBoundsException
        
        // 3. Cast de objetos:
        Object objeto = "Hola";
        // Integer entero = (Integer) objeto; // Compila OK, pero ClassCastException
        
        // 4. Referencias nulas:
        String texto = null;
        // int longitud = texto.length(); // Compila OK, pero NullPointerException
    }
}
```

#### **Comparaci√≥n con otros lenguajes**

##### **Java vs JavaScript (tipado d√©bil/din√°mico):**
```javascript
// JavaScript - Conversiones autom√°ticas "m√°gicas"
console.log(5 + "3");        // "53" (n√∫mero + string = concatenaci√≥n)
console.log("5" - 3);        // 2 (string - n√∫mero = resta matem√°tica)
console.log(true + 1);       // 2 (boolean + n√∫mero = suma)
console.log([] + {});        // "[object Object]" (¬°comportamiento inesperado!)
```

```java
// Java - Conversiones expl√≠citas y controladas
public class ComparacionJS {
    public static void main(String[] args) {
        // ‚ùå Java NO permite estas "conversiones m√°gicas":
        // System.out.println(5 + "3");     // OK: concatenaci√≥n, pero resultado es String
        // System.out.println("5" - 3);     // ERROR: String no tiene operador -
        // System.out.println(true + 1);    // ERROR: boolean + int incompatible
        
        // ‚úÖ Java requiere intenci√≥n clara:
        System.out.println(5 + "3");                    // "53" (concatenaci√≥n)
        System.out.println(Integer.parseInt("5") - 3);  // 2 (conversi√≥n + resta)
        System.out.println((true ? 1 : 0) + 1);        // 2 (conversi√≥n expl√≠cita boolean‚Üíint)
    }
}
```

##### **Java vs Python (tipado fuerte/din√°mico):**
```python
# Python - Tipado fuerte pero din√°mico
numero = 42        # int
numero = "cuarenta" # Ahora es str (cambio de tipo en ejecuci√≥n)
numero = [1, 2, 3] # Ahora es list

# Error solo se descubre AL EJECUTAR:
def procesar(x):
    return x + 10

procesar(5)        # OK: 15
procesar("hola")   # ¬°RuntimeError! Solo se descubre al llamar la funci√≥n
```

```java
// Java - Tipado fuerte y est√°tico
public class ComparacionPython {
    public static void main(String[] args) {
        int numero = 42;
        // numero = "cuarenta";  // ‚ùå ERROR DE COMPILACI√ìN: tipo no puede cambiar
        
        // Los errores se detectan ANTES de ejecutar:
        // procesar("hola");     // ‚ùå ERROR DE COMPILACI√ìN: String no es int
        procesar(5);             // ‚úÖ OK: tipo verificado en compilaci√≥n
    }
    
    public static int procesar(int x) {
        return x + 10;
    }
}
```

#### **Ventajas y desventajas**

##### **‚úÖ Ventajas del tipado fuerte y est√°tico:**

1. **Detecci√≥n temprana de errores**
2. **Mejor rendimiento** (optimizaciones en compilaci√≥n)
3. **Mejor soporte de herramientas** (IDEs, refactoring)
4. **C√≥digo autodocumentado** (los tipos son documentaci√≥n)
5. **Mayor confiabilidad** en aplicaciones grandes
6. **Refactoring m√°s seguro**

##### **‚ùå Desventajas potenciales:**

1. **M√°s verboso**: Requiere declaraciones expl√≠citas de tipos
2. **Menos flexibilidad**: No permite cambios din√°micos de tipo
3. **Curva de aprendizaje**: Desarrolladores de lenguajes din√°micos necesitan adaptaci√≥n
4. **C√≥digo m√°s largo**: Conversiones expl√≠citas requieren m√°s l√≠neas

#### **Mejores pr√°cticas con el sistema de tipos**

##### **1. Usar tipos m√°s espec√≠ficos cuando sea posible:**
```java
// ‚ùå Menos espec√≠fico:
Object dato = "Hola mundo";
List lista = new ArrayList();

// ‚úÖ M√°s espec√≠fico:
String mensaje = "Hola mundo";
List<String> nombres = new ArrayList<String>();
```

##### **2. Evitar castings innecesarios:**
```java
// ‚ùå Cast innecesario:
double resultado = (double) (10 + 20);  // 10 + 20 ya es double

// ‚úÖ Mejor:
double resultado = 10.0 + 20;  // Promoci√≥n autom√°tica a double
```

##### **3. Validar antes de cast peligrosos:**
```java
// ‚ùå Cast directo (peligroso):
Object obj = obtenerObjeto();
String texto = (String) obj; // Puede lanzar ClassCastException

// ‚úÖ Validaci√≥n antes de cast:
Object obj = obtenerObjeto();
if (obj instanceof String) {
    String texto = (String) obj; // Seguro
    System.out.println("Texto: " + texto);
} else {
    System.out.println("El objeto no es un String");
}
```

El tipado fuerte y est√°tico de Java es uno de sus pilares fundamentales, proporcionando seguridad, rendimiento y mantenibilidad, especialmente crucial en aplicaciones empresariales grandes y complejas.

### üéØ **Ejercicios pr√°cticos para Case Sensitivity**

#### **Ejercicio 1: Identificar errores de case sensitivity**
```java
public class EjercicioCaseSensitivity {
    public static void main(String[] args) {
        // ¬øCu√°les de estas l√≠neas compilan y cu√°les no?
        String mensaje = "Hola Mundo";
        // STRING mensaje2 = "Error";        // ‚ùå Error: STRING no existe
        // string mensaje3 = "Error";        // ‚ùå Error: string no existe (debe ser String)
        
        int numero = 42;
        // INT numero2 = 43;                 // ‚ùå Error: INT no existe (debe ser int)
        
        // System.Out.println(mensaje);      // ‚ùå Error: Out debe ser out
        System.out.println(mensaje);         // ‚úÖ Correcto
        
        // Public static void main...        // ‚ùå Error: Public debe ser public
        // SYSTEM.OUT.PRINTLN("Error");      // ‚ùå Error: todo debe estar en min√∫sculas apropiadas
        
        // ¬øEstas variables son diferentes?
        String nombre = "Juan";
        String Nombre = "Pedro";
        String NOMBRE = "Ana";
        String NoMbRe = "Luis";
        
        System.out.println("nombre: " + nombre);   // Juan
        System.out.println("Nombre: " + Nombre);   // Pedro
        System.out.println("NOMBRE: " + NOMBRE);   // Ana
        System.out.println("NoMbRe: " + NoMbRe);   // Luis
    }
}
```

#### **Ejercicio 2: Convenciones de nombres**
```java
public class EjercicioConvenciones {
    // Variables: camelCase
    private String nombreCompleto = "Juan P√©rez";
    private int edadPersona = 25;
    private boolean estaActivo = true;
    
    // Constantes: UPPER_SNAKE_CASE  
    private static final String NOMBRE_APLICACION = "Mi App";
    private static final int MAXIMO_INTENTOS = 3;
    private static final double PI_VALOR = 3.141592653589793;
    
    // M√©todos: camelCase
    public void mostrarInformacion() {
        System.out.println("Nombre: " + nombreCompleto);
        System.out.println("Edad: " + edadPersona);
        System.out.println("Activo: " + estaActivo);
    }
    
    public int calcularAniosParaJubilacion() {
        final int EDAD_JUBILACION = 65;
        return EDAD_JUBILACION - edadPersona;
    }
    
    // M√©todo main: punto de entrada
    public static void main(String[] args) {
        EjercicioConvenciones persona = new EjercicioConvenciones();
        persona.mostrarInformacion();
        
        System.out.println("A√±os para jubilaci√≥n: " + 
                         persona.calcularAniosParaJubilacion());
        System.out.println("Aplicaci√≥n: " + NOMBRE_APLICACION);
        System.out.println("Valor de PI: " + PI_VALOR);
    }
}
```

#### **Ejercicio 3: Errores comunes de principiantes**
```java
public class ErroresComunesCaseSensitivity {
    public static void main(String[] args) {
        // ERROR 1: Confundir palabras reservadas
        // string texto = "Error";          // ‚ùå string no existe, debe ser String
        String texto = "Correcto";          // ‚úÖ String con S may√∫scula
        
        // ERROR 2: M√©todos de String mal escritos  
        String saludo = "hola mundo";
        // saludo.ToUpperCase();            // ‚ùå ToUpperCase no existe
        System.out.println(saludo.toUpperCase()); // ‚úÖ toUpperCase con t min√∫scula
        
        // ERROR 3: Confundir System.out
        // system.out.println("Error");     // ‚ùå system debe ser System
        // System.Out.println("Error");     // ‚ùå Out debe ser out
        System.out.println("Correcto");    // ‚úÖ System.out
        
        // ERROR 4: Clases vs instancias
        // math.sqrt(25);                   // ‚ùå math no existe
        System.out.println(Math.sqrt(25));  // ‚úÖ Math con M may√∫scula
        
        // ERROR 5: Variables vs m√©todos
        String nombre = "Java";
        // System.out.println(Nombre);      // ‚ùå Nombre no existe (variable es nombre)
        System.out.println(nombre);         // ‚úÖ Variable correcta
        // System.out.println(nombre.Length); // ‚ùå Length no existe
        System.out.println(nombre.length()); // ‚úÖ length() con l min√∫scula
    }
}
```

---

### üè∑Ô∏è **CONCEPTO 5: Variables est√°ticas vs de instancia**

En Java existen dos tipos principales de variables en las clases: **variables de instancia** (pertenecen a objetos individuales) y **variables est√°ticas** (pertenecen a la clase como un todo). Entender esta diferencia es fundamental para el dise√±o orientado a objetos.

#### **Variables de instancia (Non-static)**

##### **Definici√≥n y caracter√≠sticas:**
- Pertenecen a **objetos espec√≠ficos** (instancias de la clase)
- Cada objeto tiene su **propia copia** de la variable
- Se crean cuando se instancia un objeto con `new`
- Se destruyen cuando el objeto es recolectado por el Garbage Collector
- **NO** pueden accederse sin crear un objeto primero

##### **Ejemplo b√°sico:**
```java
public class Estudiante {
    // Variables de instancia
    private String nombre;        // Cada estudiante tiene su propio nombre
    private int edad;            // Cada estudiante tiene su propia edad  
    private double promedio;     // Cada estudiante tiene su propio promedio
    
    public Estudiante(String nombre, int edad) {
        this.nombre = nombre;    // 'this' se refiere a esta instancia espec√≠fica
        this.edad = edad;
        this.promedio = 0.0;
    }
    
    // M√©todos de instancia (pueden acceder a variables de instancia)
    public void mostrarInfo() {
        System.out.println("Estudiante: " + nombre + ", Edad: " + edad);
    }
    
    // Getters y Setters
    public String getNombre() { return nombre; }
    public int getEdad() { return edad; }
    public double getPromedio() { return promedio; }
    public void setPromedio(double promedio) { this.promedio = promedio; }
}
```

##### **Uso de variables de instancia:**
```java
public class EjemploInstancia {
    public static void main(String[] args) {
        // Crear m√∫ltiples objetos - cada uno tiene SUS PROPIAS variables
        Estudiante student1 = new Estudiante("Ana", 20);
        Estudiante student2 = new Estudiante("Carlos", 22);
        Estudiante student3 = new Estudiante("Mar√≠a", 19);
        
        // Modificar variables de instancia independientemente
        student1.setPromedio(8.5);
        student2.setPromedio(9.2);
        student3.setPromedio(7.8);
        
        // Cada objeto mantiene sus propios valores
        System.out.println(student1.getNombre() + " - Promedio: " + student1.getPromedio()); // Ana - 8.5
        System.out.println(student2.getNombre() + " - Promedio: " + student2.getPromedio()); // Carlos - 9.2
        System.out.println(student3.getNombre() + " - Promedio: " + student3.getPromedio()); // Mar√≠a - 7.8
        
        // Cada objeto es independiente:
        System.out.println("Objetos en memoria:");
        System.out.println("student1: " + student1); // Estudiante@15db9742
        System.out.println("student2: " + student2); // Estudiante@6d06d69c  
        System.out.println("student3: " + student3); // Estudiante@7852e922
    }
}
```

#### **Variables est√°ticas (Static)**

##### **Definici√≥n y caracter√≠sticas:**
- Pertenecen a **la clase**, no a objetos espec√≠ficos
- **Una sola copia** compartida por todos los objetos de la clase
- Se crean cuando la clase se carga por primera vez en memoria
- Existen durante toda la vida del programa
- Se pueden acceder **sin crear objetos**: `Clase.variableEstatica`
- Tambi√©n llamadas "variables de clase"

##### **Ejemplo b√°sico:**
```java
public class Contador {
    // Variable est√°tica - COMPARTIDA por todas las instancias
    private static int totalObjetos = 0;
    
    // Variable de instancia - √öNICA para cada objeto
    private int numeroObjeto;
    
    public Contador() {
        totalObjetos++;                    // Incrementa el contador GLOBAL
        this.numeroObjeto = totalObjetos;  // Asigna n√∫mero √∫nico a ESTA instancia
    }
    
    // M√©todo est√°tico - puede acceder solo a variables est√°ticas
    public static int getTotalObjetos() {
        return totalObjetos;
        // return numeroObjeto; // ‚ùå ERROR: no puede acceder a variables de instancia
    }
    
    // M√©todo de instancia - puede acceder a ambos tipos de variables
    public int getNumeroObjeto() {
        return numeroObjeto;               // Variable de instancia - OK
    }
    
    public static int getTotalObjetosMetodoInstancia() {
        return totalObjetos;               // Variable est√°tica - OK
    }
    
    public void mostrarInfo() {
        System.out.println("Soy el objeto #" + numeroObjeto + 
                          " de un total de " + totalObjetos + " objetos");
    }
}
```

##### **Uso de variables est√°ticas:**
```java
public class EjemploEstatico {
    public static void main(String[] args) {
        // Acceso a variable est√°tica SIN crear objetos
        System.out.println("Objetos iniciales: " + Contador.getTotalObjetos()); // 0
        
        // Crear objetos - la variable est√°tica se comparte
        Contador obj1 = new Contador();
        System.out.println("Despu√©s de crear obj1: " + Contador.getTotalObjetos()); // 1
        
        Contador obj2 = new Contador();
        System.out.println("Despu√©s de crear obj2: " + Contador.getTotalObjetos()); // 2
        
        Contador obj3 = new Contador();
        System.out.println("Despu√©s de crear obj3: " + Contador.getTotalObjetos()); // 3
        
        // Todos los objetos ven el MISMO valor est√°tico
        obj1.mostrarInfo(); // Soy el objeto #1 de un total de 3 objetos
        obj2.mostrarInfo(); // Soy el objeto #2 de un total de 3 objetos  
        obj3.mostrarInfo(); // Soy el objeto #3 de un total de 3 objetos
        
        // Variables de instancia son independientes:
        System.out.println("obj1 n√∫mero: " + obj1.getNumeroObjeto()); // 1
        System.out.println("obj2 n√∫mero: " + obj2.getNumeroObjeto()); // 2
        System.out.println("obj3 n√∫mero: " + obj3.getNumeroObjeto()); // 3
    }
}
```

#### **Comparaci√≥n detallada**

##### **Tabla comparativa:**

| Aspecto | Variables de Instancia | Variables Est√°ticas |
|---------|----------------------|-------------------|
| **Declaraci√≥n** | `private int edad;` | `private static int contador;` |
| **Pertenencia** | Objeto espec√≠fico | Toda la clase |
| **Memoria** | Una copia por objeto | Una copia total |
| **Acceso** | `objeto.variable` | `Clase.variable` |
| **Creaci√≥n** | Con `new Objeto()` | Al cargar la clase |
| **Destrucci√≥n** | Con Garbage Collection | Al finalizar programa |
| **Acceso desde m√©todos est√°ticos** | ‚ùå NO | ‚úÖ S√ç |
| **Acceso desde m√©todos de instancia** | ‚úÖ S√ç | ‚úÖ S√ç |

##### **Ejemplo completo comparativo:**
```java
public class EjemploCompleto {
    // Variable est√°tica - compartida por todas las instancias
    private static String institucion = "Universidad Central";
    private static int totalEstudiantes = 0;
    
    // Variables de instancia - √∫nicas para cada objeto
    private String nombre;
    private int id;
    private double promedio;
    
    // Constructor
    public EjemploCompleto(String nombre, double promedio) {
        this.nombre = nombre;
        this.promedio = promedio;
        
        totalEstudiantes++;        // Incrementa contador global
        this.id = totalEstudiantes; // ID √∫nico basado en contador
    }
    
    // M√©todo est√°tico - solo accede a variables est√°ticas
    public static void mostrarInfoInstitucion() {
        System.out.println("Instituci√≥n: " + institucion);
        System.out.println("Total estudiantes: " + totalEstudiantes);
        // System.out.println(nombre); // ‚ùå ERROR: no puede acceder a variables de instancia
    }
    
    // M√©todo de instancia - puede acceder a ambos tipos
    public void mostrarInfoCompleta() {
        System.out.println("=== INFORMACI√ìN COMPLETA ===");
        System.out.println("Instituci√≥n: " + institucion);      // Variable est√°tica - OK
        System.out.println("Total estudiantes: " + totalEstudiantes); // Variable est√°tica - OK
        System.out.println("ID: " + id);                        // Variable de instancia - OK
        System.out.println("Nombre: " + nombre);                // Variable de instancia - OK
        System.out.println("Promedio: " + promedio);            // Variable de instancia - OK
    }
    
    // M√©todo est√°tico para cambiar datos de la instituci√≥n
    public static void cambiarInstitucion(String nuevaInstitucion) {
        institucion = nuevaInstitucion; // Afecta a TODOS los estudiantes
    }
    
    // Getters
    public String getNombre() { return nombre; }
    public int getId() { return id; }
    public static int getTotalEstudiantes() { return totalEstudiantes; }
}
```

La comprensi√≥n de variables est√°ticas vs de instancia es esencial para dise√±ar clases eficientes y escribir c√≥digo Java orientado a objetos correcto y mantenible.

---

## üñ•Ô∏è **CONCEPTO 3: Salida est√°ndar (System.out)**

`System.out` es la forma m√°s com√∫n de mostrar informaci√≥n en la consola en Java. Es un objeto de tipo `PrintStream` que representa la **salida est√°ndar** del programa.

### **¬øQu√© es System.out?**

```java
System.out  // Objeto est√°tico para salida est√°ndar
  ‚Ü≥ System     // Clase del sistema Java
  ‚Ü≥ out        // Campo est√°tico de tipo PrintStream  
  ‚Ü≥ println()  // M√©todo para imprimir con salto de l√≠nea
```

### **üéØ M√©todos principales de System.out**

#### **1. println() - Imprimir con salto de l√≠nea**

```java
public class EjemplosPrintln {
    public static void main(String[] args) {
        // Imprimir texto simple
        System.out.println("¬°Hola, Mundo!");
        
        // Imprimir variables
        String nombre = "Juan";
        int edad = 25;
        System.out.println("Nombre: " + nombre);
        System.out.println("Edad: " + edad);
        
        // Imprimir expresiones matem√°ticas
        System.out.println("5 + 3 = " + (5 + 3));
        
        // Imprimir diferentes tipos de datos
        System.out.println(true);           // boolean
        System.out.println(3.14159);        // double
        System.out.println('A');            // char
        
        // L√≠nea vac√≠a
        System.out.println();  // Solo salto de l√≠nea
    }
}
```

**üí° Salida esperada:**
```
¬°Hola, Mundo!
Nombre: Juan
Edad: 25
5 + 3 = 8
true
3.14159
A

```

#### **2. print() - Imprimir sin salto de l√≠nea**

```java
public class EjemplosPrint {
    public static void main(String[] args) {
        // print() no agrega salto de l√≠nea
        System.out.print("Hola ");
        System.out.print("Mundo ");
        System.out.println("Java!");  // Esta s√≠ hace salto
        
        // √ötil para contadores o progreso
        System.out.print("Cargando");
        for (int i = 0; i < 5; i++) {
            System.out.print(".");
            // En aplicaci√≥n real har√≠as Thread.sleep(500);
        }
        System.out.println(" ¬°Completo!");
        
        // Crear l√≠neas formateadas
        System.out.print("Nombre: ");
        System.out.print("Mar√≠a Garc√≠a");
        System.out.print(" | Edad: ");
        System.out.println("28");
    }
}
```

**üí° Salida esperada:**
```
Hola Mundo Java!
Cargando..... ¬°Completo!
Nombre: Mar√≠a Garc√≠a | Edad: 28
```

#### **3. printf() - Imprimir con formato espec√≠fico**

```java
public class EjemplosPrintf {
    public static void main(String[] args) {
        // Variables de ejemplo
        String nombre = "Ana";
        int edad = 30;
        double altura = 1.65;
        boolean estudiante = true;
        
        // Formato b√°sico
        System.out.printf("Hola %s%n", nombre);
        
        // M√∫ltiples variables
        System.out.printf("Nombre: %s, Edad: %d a√±os%n", nombre, edad);
        
        // N√∫meros decimales con precisi√≥n
        System.out.printf("Altura: %.2f metros%n", altura);
        
        // Formato completo
        System.out.printf("Perfil: %s (%d a√±os, %.2f m) - ¬øEstudiante? %b%n", 
                         nombre, edad, altura, estudiante);
        
        // Formato de tabla
        System.out.printf("%-15s | %5s | %8s%n", "NOMBRE", "EDAD", "ALTURA");
        System.out.printf("%-15s | %5d | %8.2f%n", "Ana Garc√≠a", 30, 1.65);
        System.out.printf("%-15s | %5d | %8.2f%n", "Luis Mart√≠n", 25, 1.78);
        
        // Formato de moneda
        double precio = 1234.56;
        System.out.printf("Precio: $%,.2f%n", precio);
    }
}
```

**üí° Salida esperada:**
```
Hola Ana
Nombre: Ana, Edad: 30 a√±os
Altura: 1.65 metros
Perfil: Ana (30 a√±os, 1.65 m) - ¬øEstudiante? true
NOMBRE          |  EDAD |   ALTURA
Ana Garc√≠a      |    30 |     1.65
Luis Mart√≠n     |    25 |     1.78
Precio: $1,234.56
```

### **üìã Especificadores de formato m√°s comunes**

| Especificador | Tipo | Descripci√≥n | Ejemplo |
|---------------|------|-------------|---------|
| `%s` | String | Cadena de texto | `"Hola"` |
| `%d` | int/long | N√∫mero entero | `123` |
| `%f` | float/double | N√∫mero decimal | `3.14159` |
| `%.2f` | float/double | Decimal con 2 decimales | `3.14` |
| `%c` | char | Car√°cter individual | `'A'` |
| `%b` | boolean | Valor verdadero/falso | `true` |
| `%n` | - | Salto de l√≠nea | Nueva l√≠nea |
| `%%` | - | S√≠mbolo % literal | `%` |

### **üé® Modificadores de formato avanzados**

```java
public class FormatosAvanzados {
    public static void main(String[] args) {
        int numero = 42;
        
        // Ancho de campo
        System.out.printf("|%5d|%n", numero);        // |   42|
        System.out.printf("|%-5d|%n", numero);       // |42   |
        System.out.printf("|%05d|%n", numero);       // |00042|
        
        // N√∫meros grandes con separadores
        int grande = 1234567;
        System.out.printf("N√∫mero: %,d%n", grande);   // 1,234,567
        
        // Hexadecimal y octal
        System.out.printf("Decimal: %d, Hex: %x, Octal: %o%n", 255, 255, 255);
        // Decimal: 255, Hex: ff, Octal: 377
        
        // Fechas y tiempo (b√°sico)
        System.out.printf("A√±o actual: %tY%n", new java.util.Date());
    }
}
```

### **üîß Casos de uso pr√°cticos en desarrollo**

#### **1. Debugging y desarrollo:**
```java
public class DebugEjemplo {
    public static void main(String[] args) {
        int[] numeros = {10, 20, 30, 40, 50};
        
        // Debug: mostrar estado de variables
        System.out.println("=== INICIO PROCESO ===");
        System.out.println("Array length: " + numeros.length);
        
        int suma = 0;
        for (int i = 0; i < numeros.length; i++) {
            suma += numeros[i];
            // Debug: mostrar progreso
            System.out.printf("Paso %d: %d + %d = %d%n", 
                            i+1, suma-numeros[i], numeros[i], suma);
        }
        
        System.out.println("=== RESULTADO FINAL ===");
        System.out.printf("Suma total: %d%n", suma);
        System.out.printf("Promedio: %.2f%n", (double)suma / numeros.length);
    }
}
```

#### **2. Interfaz de usuario b√°sica:**
```java
public class MenuEjemplo {
    public static void main(String[] args) {
        // Mostrar men√∫ de opciones
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë      CALCULADORA         ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë 1. Sumar                 ‚ïë");
        System.out.println("‚ïë 2. Restar                ‚ïë");
        System.out.println("‚ïë 3. Multiplicar           ‚ïë");
        System.out.println("‚ïë 4. Dividir               ‚ïë");
        System.out.println("‚ïë 0. Salir                 ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        System.out.print("Seleccione una opci√≥n: ");
        
        // En aplicaci√≥n real, aqu√≠ leer√≠as la entrada del usuario
    }
}
```

#### **3. Reportes y tablas:**
```java
public class ReporteEjemplo {
    public static void main(String[] args) {
        // Datos de ejemplo
        String[][] productos = {
            {"Laptop", "1200.00", "5"},
            {"Mouse", "25.99", "20"},
            {"Teclado", "75.50", "12"}
        };
        
        // Encabezado del reporte
        System.out.println("REPORTE DE INVENTARIO");
        System.out.println("=====================");
        System.out.printf("%-10s | %10s | %8s | %10s%n", 
                         "PRODUCTO", "PRECIO", "STOCK", "VALOR");
        System.out.println("-".repeat(45));
        
        double totalValor = 0;
        for (String[] producto : productos) {
            double precio = Double.parseDouble(producto[1]);
            int stock = Integer.parseInt(producto[2]);
            double valor = precio * stock;
            totalValor += valor;
            
            System.out.printf("%-10s | $%9.2f | %8d | $%9.2f%n", 
                             producto[0], precio, stock, valor);
        }
        
        System.out.println("-".repeat(45));
        System.out.printf("TOTAL INVENTARIO: $%,10.2f%n", totalValor);
    }
}
```

### **‚ö†Ô∏è Consideraciones importantes**

#### **1. Rendimiento:**
```java
// ‚ùå Ineficiente para muchas impresiones
for (int i = 0; i < 10000; i++) {
    System.out.println("L√≠nea " + i);  // Lento
}

// ‚úÖ Mejor para muchas impresiones
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append("L√≠nea ").append(i).append("\n");
}
System.out.print(sb.toString());  // Una sola llamada
```

#### **2. Manejo de caracteres especiales:**
```java
public class CaracteresEspeciales {
    public static void main(String[] args) {
        // Caracteres de escape
        System.out.println("Comillas: \"Hola\"");           // "Hola"
        System.out.println("Apostrofe: 'Mundo'");           // 'Mundo'
        System.out.println("Barra invertida: \\Java\\");    // \Java\
        System.out.println("Nueva l√≠nea: L√≠nea1\nL√≠nea2");  
        System.out.println("Tabulaci√≥n: Col1\tCol2");       
        
        // Unicode
        System.out.println("S√≠mbolos: \u2764 \u2665 \u2666"); // ‚ô• ‚ô¶
    }
}
```

### **üéØ Ejercicios pr√°cticos**

#### **Ejercicio 1: Calculadora de informaci√≥n personal**
```java
// Crea un programa que muestre tu informaci√≥n usando printf
public class MiInformacion {
    public static void main(String[] args) {
        // TODO: Completa con tus datos
        String nombre = "Tu Nombre";
        int edad = 0;
        double altura = 0.0;
        char inicial = 'X';
        boolean programador = false;
        
        // Usa printf para mostrar la informaci√≥n formateada
        System.out.printf("=== MI PERFIL ===%n");
        // Completar aqu√≠...
    }
}
```

#### **Ejercicio 2: Tabla de multiplicar**
```java
// Crea una tabla de multiplicar del 1 al 10 bien formateada
public class TablaMultiplicar {
    public static void main(String[] args) {
        int numero = 7; // Cambia este n√∫mero
        
        System.out.printf("TABLA DE MULTIPLICAR DEL %d%n", numero);
        System.out.println("========================");
        
        // TODO: Crear la tabla usando printf
        // Formato: "7 x 1 = 7"
    }
}
```

La comprensi√≥n de variables est√°ticas vs de instancia es esencial para dise√±ar clases eficientes y escribir c√≥digo Java orientado a objetos correcto y mantenible.

### üéØ **Ejercicios pr√°cticos para Variables est√°ticas vs de instancia**

#### **Ejercicio 1: Contador de objetos**
```java
public class ContadorVehiculos {
    // Variable est√°tica - compartida por todos los veh√≠culos
    private static int totalVehiculos = 0;
    private static String concesionario = "AutoMax";
    
    // Variables de instancia - √∫nicas para cada veh√≠culo
    private String marca;
    private String modelo;
    private int numeroSerie;
    private double precio;
    
    public ContadorVehiculos(String marca, String modelo, double precio) {
        this.marca = marca;
        this.modelo = modelo;
        this.precio = precio;
        
        // Cada vez que se crea un veh√≠culo, incrementa el contador
        totalVehiculos++;
        this.numeroSerie = totalVehiculos;
    }
    
    // M√©todo est√°tico - accede solo a variables est√°ticas
    public static void mostrarEstadisticasConcesionario() {
        System.out.println("=== ESTAD√çSTICAS DEL CONCESIONARIO ===");
        System.out.println("Concesionario: " + concesionario);
        System.out.println("Total veh√≠culos registrados: " + totalVehiculos);
        // System.out.println(marca); // ‚ùå Error: no puede acceder a variables de instancia
    }
    
    // M√©todo de instancia - accede a ambos tipos de variables
    public void mostrarDetallesVehiculo() {
        System.out.println("--- Veh√≠culo #" + numeroSerie + " ---");
        System.out.println("Concesionario: " + concesionario);  // Variable est√°tica
        System.out.println("Marca: " + marca);                  // Variable de instancia
        System.out.println("Modelo: " + modelo);                // Variable de instancia
        System.out.println("Precio: $" + precio);               // Variable de instancia
        System.out.println("Total en inventario: " + totalVehiculos); // Variable est√°tica
    }
    
    public static void main(String[] args) {
        // Mostrar estad√≠sticas iniciales
        ContadorVehiculos.mostrarEstadisticasConcesionario();
        
        // Crear veh√≠culos
        ContadorVehiculos auto1 = new ContadorVehiculos("Toyota", "Corolla", 22000);
        ContadorVehiculos auto2 = new ContadorVehiculos("Honda", "Civic", 24000);
        ContadorVehiculos auto3 = new ContadorVehiculos("Ford", "Focus", 21000);
        
        // Mostrar detalles individuales
        auto1.mostrarDetallesVehiculo();
        auto2.mostrarDetallesVehiculo();
        auto3.mostrarDetallesVehiculo();
        
        // Estad√≠sticas finales
        ContadorVehiculos.mostrarEstadisticasConcesionario();
    }
}
```

#### **Ejercicio 2: Sistema bancario**
```java
public class CuentaBancaria {
    // Variables est√°ticas - informaci√≥n del banco
    private static String nombreBanco = "Banco Java";
    private static double tasaInteresBase = 0.02; // 2% anual
    private static int totalCuentasCreadas = 0;
    
    // Variables de instancia - informaci√≥n espec√≠fica de la cuenta
    private String numeroCuenta;
    private String titular;
    private double saldo;
    private String tipoCuenta;
    
    public CuentaBancaria(String titular, String tipoCuenta, double saldoInicial) {
        this.titular = titular;
        this.tipoCuenta = tipoCuenta;
        this.saldo = saldoInicial;
        
        // Generar n√∫mero de cuenta √∫nico
        totalCuentasCreadas++;
        this.numeroCuenta = "JAVA-" + String.format("%06d", totalCuentasCreadas);
    }
    
    // M√©todo est√°tico para cambiar configuraci√≥n del banco
    public static void configurarBanco(String nuevoNombre, double nuevaTasa) {
        nombreBanco = nuevoNombre;
        tasaInteresBase = nuevaTasa;
        System.out.println("Configuraci√≥n del banco actualizada:");
        System.out.println("Nombre: " + nombreBanco);
        System.out.println("Nueva tasa: " + (nuevaTasa * 100) + "%");
    }
    
    // M√©todo de instancia para operaciones de cuenta
    public void depositar(double cantidad) {
        if (cantidad > 0) {
            saldo += cantidad;
            System.out.printf("Dep√≥sito realizado: $%.2f. Nuevo saldo: $%.2f%n", 
                            cantidad, saldo);
        }
    }
    
    public void retirar(double cantidad) {
        if (cantidad > 0 && cantidad <= saldo) {
            saldo -= cantidad;
            System.out.printf("Retiro realizado: $%.2f. Nuevo saldo: $%.2f%n", 
                            cantidad, saldo);
        } else {
            System.out.println("Fondos insuficientes o cantidad inv√°lida");
        }
    }
    
    public void calcularIntereses() {
        double interes = saldo * tasaInteresBase; // Usa variable est√°tica
        saldo += interes;
        System.out.printf("Intereses aplicados: $%.2f. Nuevo saldo: $%.2f%n", 
                        interes, saldo);
    }
    
    // M√©todo para mostrar informaci√≥n completa
    public void mostrarInformacionCompleta() {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë              INFORMACI√ìN DE CUENTA           ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.printf("‚ïë Banco:        %-30s ‚ïë%n", nombreBanco);
        System.out.printf("‚ïë Cuenta:       %-30s ‚ïë%n", numeroCuenta);
        System.out.printf("‚ïë Titular:      %-30s ‚ïë%n", titular);
        System.out.printf("‚ïë Tipo:         %-30s ‚ïë%n", tipoCuenta);
        System.out.printf("‚ïë Saldo:        $%-29.2f ‚ïë%n", saldo);
        System.out.printf("‚ïë Tasa inter√©s: %-30.2f%% ‚ïë%n", tasaInteresBase * 100);
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
    }
    
    public static void main(String[] args) {
        System.out.println("Total cuentas iniciales: " + totalCuentasCreadas);
        
        // Crear cuentas
        CuentaBancaria cuenta1 = new CuentaBancaria("Ana Garc√≠a", "Ahorro", 1000);
        CuentaBancaria cuenta2 = new CuentaBancaria("Luis Mart√≠n", "Corriente", 500);
        
        // Operaciones individuales
        cuenta1.depositar(200);
        cuenta1.calcularIntereses();
        cuenta1.mostrarInformacionCompleta();
        
        cuenta2.retirar(100);
        cuenta2.calcularIntereses();
        cuenta2.mostrarInformacionCompleta();
        
        // Cambiar configuraci√≥n del banco (afecta a todas las cuentas)
        CuentaBancaria.configurarBanco("Banco Super Java", 0.025);
        
        // Los intereses ahora se calculan con la nueva tasa
        System.out.println("\n--- Despu√©s del cambio de configuraci√≥n ---");
        cuenta1.calcularIntereses();
        cuenta2.calcularIntereses();
        
        System.out.println("Total cuentas creadas: " + totalCuentasCreadas);
    }
}
```

#### **Ejercicio 3: Juego con puntuaci√≥n global**
```java
public class JuegoArcade {
    // Variables est√°ticas - informaci√≥n global del juego
    private static String nombreJuego = "Super Java Adventure";
    private static int recordMundial = 0;
    private static String poseedorRecord = "Ninguno";
    private static int totalPartidas = 0;
    
    // Variables de instancia - informaci√≥n del jugador
    private String nombreJugador;
    private int puntuacion;
    private int nivel;
    private boolean juegoTerminado;
    
    public JuegoArcade(String nombreJugador) {
        this.nombreJugador = nombreJugador;
        this.puntuacion = 0;
        this.nivel = 1;
        this.juegoTerminado = false;
        totalPartidas++;
        
        System.out.println("¬°Nuevo juego iniciado para " + nombreJugador + "!");
    }
    
    // M√©todo est√°tico para mostrar estad√≠sticas globales
    public static void mostrarEstadisticasGlobales() {
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("        " + nombreJuego.toUpperCase());
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
        System.out.println("Record mundial: " + recordMundial + " pts");
        System.out.println("Poseedor: " + poseedorRecord);
        System.out.println("Total partidas: " + totalPartidas);
        System.out.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
    }
    
    // M√©todos de instancia para gameplay
    public void ganarPuntos(int puntos) {
        if (!juegoTerminado) {
            puntuacion += puntos;
            System.out.printf("%s gan√≥ %d puntos. Total: %d%n", 
                            nombreJugador, puntos, puntuacion);
            
            // Verificar si es nuevo record
            if (puntuacion > recordMundial) {
                recordMundial = puntuacion;
                poseedorRecord = nombreJugador;
                System.out.println("üéâ ¬°NUEVO RECORD MUNDIAL! üéâ");
            }
        }
    }
    
    public void subirNivel() {
        if (!juegoTerminado) {
            nivel++;
            int bonus = nivel * 50;
            puntuacion += bonus;
            System.out.printf("¬°%s subi√≥ al nivel %d! Bonus: %d puntos%n", 
                            nombreJugador, nivel, bonus);
        }
    }
    
    public void terminarJuego() {
        juegoTerminado = true;
        System.out.printf("Juego terminado para %s%n", nombreJugador);
        System.out.printf("Puntuaci√≥n final: %d puntos, Nivel: %d%n", 
                        puntuacion, nivel);
        
        if (puntuacion == recordMundial) {
            System.out.println("¬°Tienes el record mundial!");
        } else {
            System.out.printf("Te faltan %d puntos para el record%n", 
                            recordMundial - puntuacion);
        }
    }
    
    public void mostrarEstadoJugador() {
        System.out.println("--- Estado del Jugador ---");
        System.out.println("Jugador: " + nombreJugador);
        System.out.println("Puntuaci√≥n: " + puntuacion);
        System.out.println("Nivel: " + nivel);
        System.out.println("Estado: " + (juegoTerminado ? "Terminado" : "Jugando"));
        System.out.println("Record a superar: " + recordMundial);
    }
    
    public static void main(String[] args) {
        // Mostrar estad√≠sticas iniciales
        JuegoArcade.mostrarEstadisticasGlobales();
        
        // Primer jugador
        JuegoArcade jugador1 = new JuegoArcade("Mario");
        jugador1.ganarPuntos(100);
        jugador1.subirNivel();
        jugador1.ganarPuntos(150);
        jugador1.mostrarEstadoJugador();
        jugador1.terminarJuego();
        
        System.out.println();
        
        // Segundo jugador
        JuegoArcade jugador2 = new JuegoArcade("Luigi");
        jugador2.ganarPuntos(80);
        jugador2.subirNivel();
        jugador2.ganarPuntos(200);
        jugador2.subirNivel();
        jugador2.ganarPuntos(300);
        jugador2.mostrarEstadoJugador();
        jugador2.terminarJuego();
        
        // Estad√≠sticas finales
        JuegoArcade.mostrarEstadisticasGlobales();
    }
}
```

---

## üîå **CONCEPTO INTERMEDIO: INTERFACES - ¬øQu√© significa `implements Runnable`?**

### **¬øQu√© es una Interfaz en Java?**

Una **interfaz** es como un contrato que una clase debe cumplir. Define **qu√© m√©todos** debe tener una clase, pero no **c√≥mo** deben implementarse. Es una forma de lograr herencia m√∫ltiple de comportamiento en Java.

```java
// Definici√≥n b√°sica de una interfaz
public interface MiInterfaz {
    // M√©todos que deben ser implementados (abstractos por defecto)
    void metodoObligatorio();
    int otroMetodo(String parametro);
    
    // Desde Java 8: m√©todos con implementaci√≥n por defecto
    default void metodoConImplementacion() {
        System.out.println("Este m√©todo ya tiene c√≥digo");
    }
}
```

### **La Interfaz Runnable: Un caso especial**

`Runnable` es una interfaz predefinida en Java que se usa para **multihilos** (threading). Su definici√≥n es muy simple:

```java
// As√≠ est√° definida la interfaz Runnable en Java
public interface Runnable {
    public abstract void run();  // Un solo m√©todo abstracto
}
```

### **¬øPor qu√© `implements Runnable` en nuestros ejemplos?**

Cuando ves `public class Funciones implements Runnable`, significa que:

1. **La clase `Funciones` DEBE implementar el m√©todo `run()`**
2. **La clase puede ser ejecutada en un hilo separado** 
3. **Es una t√©cnica com√∫n en aplicaciones Java empresariales**

#### **Ejemplo pr√°ctico de por qu√© se usa:**

```java
// Clase que implementa Runnable para poder ejecutarse en paralelo
public class Funciones implements Runnable {
    
    // Variables de instancia para el hilo
    private String nombreHilo;
    private int tareasDeProceso;
    
    public Funciones(String nombre) {
        this.nombreHilo = nombre;
        this.tareasDeProceso = 0;
    }
    
    // M√âTODO OBLIGATORIO: debe implementarse por la interfaz Runnable
    @Override
    public void run() {
        // Este m√©todo se ejecuta cuando el hilo inicia
        System.out.println("üöÄ Hilo iniciado: " + nombreHilo);
        
        for (int i = 1; i <= 5; i++) {
            System.out.printf("‚öôÔ∏è  %s procesando tarea %d/5%n", nombreHilo, i);
            tareasDeProceso++;
            
            try {
                Thread.sleep(1000); // Simula trabajo pesado (1 segundo)
            } catch (InterruptedException e) {
                System.err.println("‚ùå Hilo interrumpido: " + nombreHilo);
                return;
            }
        }
        
        System.out.printf("‚úÖ %s completado. Tareas procesadas: %d%n", 
                         nombreHilo, tareasDeProceso);
    }
    
    // Otros m√©todos normales de la clase
    public static double redondear(double numero, int decimales) {
        double factor = Math.pow(10, decimales);
        return Math.round(numero * factor) / factor;
    }
    
    public void mostrarEstado() {
        System.out.printf("Hilo: %s, Tareas completadas: %d%n", 
                         nombreHilo, tareasDeProceso);
    }
}
```

#### **C√≥mo usar una clase que implementa Runnable:**

```java
public class EjemploMultihilos {
    public static void main(String[] args) {
        System.out.println("üé¨ Iniciando ejemplo de multihilos...");
        
        // Crear instancias de la clase Funciones
        Funciones proceso1 = new Funciones("Calculadora-1");
        Funciones proceso2 = new Funciones("Calculadora-2");
        Funciones proceso3 = new Funciones("Calculadora-3");
        
        // Crear hilos usando las instancias Runnable
        Thread hilo1 = new Thread(proceso1);
        Thread hilo2 = new Thread(proceso2);
        Thread hilo3 = new Thread(proceso3);
        
        // Iniciar todos los hilos AL MISMO TIEMPO
        hilo1.start();  // Llama autom√°ticamente al m√©todo run()
        hilo2.start();  // Llama autom√°ticamente al m√©todo run()
        hilo3.start();  // Llama autom√°ticamente al m√©todo run()
        
        // El hilo principal contin√∫a ejecut√°ndose
        System.out.println("üìä Hilos iniciados desde el hilo principal");
        
        try {
            // Esperar que terminen todos los hilos
            hilo1.join();
            hilo2.join();
            hilo3.join();
            
            System.out.println("üèÅ Todos los hilos han terminado");
            
            // Mostrar estado final
            proceso1.mostrarEstado();
            proceso2.mostrarEstado();
            proceso3.mostrarEstado();
            
        } catch (InterruptedException e) {
            System.err.println("‚ùå Error esperando hilos: " + e.getMessage());
        }
    }
}
```

### **Salida esperada del programa:**

```
üé¨ Iniciando ejemplo de multihilos...
üìä Hilos iniciados desde el hilo principal
üöÄ Hilo iniciado: Calculadora-1
üöÄ Hilo iniciado: Calculadora-2
üöÄ Hilo iniciado: Calculadora-3
‚öôÔ∏è  Calculadora-1 procesando tarea 1/5
‚öôÔ∏è  Calculadora-2 procesando tarea 1/5
‚öôÔ∏è  Calculadora-3 procesando tarea 1/5
‚öôÔ∏è  Calculadora-1 procesando tarea 2/5
‚öôÔ∏è  Calculadora-2 procesando tarea 2/5
‚öôÔ∏è  Calculadora-3 procesando tarea 2/5
... (contin√∫a hasta que todos terminen)
‚úÖ Calculadora-1 completado. Tareas procesadas: 5
‚úÖ Calculadora-2 completado. Tareas procesadas: 5
‚úÖ Calculadora-3 completado. Tareas procesadas: 5
üèÅ Todos los hilos han terminado
Hilo: Calculadora-1, Tareas completadas: 5
Hilo: Calculadora-2, Tareas completadas: 5
Hilo: Calculadora-3, Tareas completadas: 5
```

### **¬øPor qu√© es √∫til esto en aplicaciones reales?**

#### **1. Procesamiento paralelo:**
```java
// Ejemplo: procesar m√∫ltiples c√°lculos matem√°ticos simult√°neamente
public class CalculadoraParalela implements Runnable {
    private double[] numeros;
    private double resultado;
    
    public CalculadoraParalela(double[] numeros) {
        this.numeros = numeros;
    }
    
    @Override
    public void run() {
        // Cada hilo procesa una parte de los c√°lculos
        resultado = 0;
        for (double num : numeros) {
            resultado += Math.sqrt(num * num + Math.PI);
            // Simulaci√≥n de c√°lculo complejo
        }
        System.out.printf("‚úÖ C√°lculo terminado. Resultado: %.2f%n", resultado);
    }
    
    public double getResultado() { return resultado; }
}
```

#### **2. Tareas en segundo plano:**
```java
// Ejemplo: guardar datos mientras el usuario sigue trabajando
public class GuardadoAutomatico implements Runnable {
    private String datosParaGuardar;
    
    public GuardadoAutomatico(String datos) {
        this.datosParaGuardar = datos;
    }
    
    @Override
    public void run() {
        System.out.println("üíæ Guardando datos en segundo plano...");
        
        try {
            Thread.sleep(2000); // Simula escritura a disco
            // Aqu√≠ ir√≠a el c√≥digo real de guardado
            System.out.println("‚úÖ Datos guardados exitosamente");
        } catch (InterruptedException e) {
            System.err.println("‚ùå Error en guardado autom√°tico");
        }
    }
}
```

### **Diferencias importantes:**

#### **Extender Thread vs Implementar Runnable:**

```java
// OPCI√ìN 1: Extender Thread (menos flexible)
class MiHilo extends Thread {
    @Override
    public void run() {
        System.out.println("Ejecut√°ndose como Thread");
    }
}

// OPCI√ìN 2: Implementar Runnable (m√°s flexible) ‚≠ê RECOMENDADO
class MiTarea implements Runnable {
    @Override  
    public void run() {
        System.out.println("Ejecut√°ndose como Runnable");
    }
}

// Uso:
public class ComparacionHilos {
    public static void main(String[] args) {
        // Opci√≥n 1: Thread directo
        MiHilo hilo1 = new MiHilo();
        hilo1.start();
        
        // Opci√≥n 2: Runnable (m√°s vers√°til)
        MiTarea tarea = new MiTarea();
        Thread hilo2 = new Thread(tarea);
        hilo2.start();
        
        // Tambi√©n se puede usar con lambda (Java 8+)
        Thread hilo3 = new Thread(() -> {
            System.out.println("Ejecut√°ndose con lambda");
        });
        hilo3.start();
    }
}
```

### **¬øPor qu√© usar Runnable es mejor?**

1. **‚úÖ Flexibilidad**: Tu clase puede extender otra clase y a√∫n implementar Runnable
2. **‚úÖ Reutilizaci√≥n**: La misma instancia Runnable puede usarse en m√∫ltiples hilos
3. **‚úÖ Separaci√≥n de responsabilidades**: La l√≥gica de negocio est√° separada del manejo de hilos
4. **‚úÖ Compatibilidad**: Funciona bien con ExecutorService y ThreadPools modernos

### **En el contexto de nuestros ejemplos:**

Cuando veas `public class Funciones implements Runnable` en los ejemplos del README, ahora sabes que:

- **La clase puede ejecutarse en hilos paralelos** 
- **Debe implementar obligatoriamente el m√©todo `run()`**
- **Es una pr√°ctica com√∫n en aplicaciones Java empresariales**
- **Permite que las funciones matem√°ticas se ejecuten simult√°neamente**

### üéØ **Ejercicio pr√°ctico con Runnable:**

```java
public class CalculadoraAvanzada implements Runnable {
    private String operacion;
    private double num1, num2;
    private double resultado;
    
    public CalculadoraAvanzada(String op, double a, double b) {
        this.operacion = op;
        this.num1 = a;
        this.num2 = b;
    }
    
    @Override
    public void run() {
        System.out.printf("üî¢ Iniciando %s: %.2f y %.2f%n", operacion, num1, num2);
        
        try {
            Thread.sleep(500); // Simula procesamiento complejo
            
            switch (operacion.toLowerCase()) {
                case "suma":
                    resultado = num1 + num2;
                    break;
                case "multiplicacion":
                    resultado = num1 * num2;
                    break;
                case "potencia":
                    resultado = Math.pow(num1, num2);
                    break;
                case "raiz":
                    resultado = Math.sqrt(num1);
                    break;
                default:
                    resultado = 0;
            }
            
            System.out.printf("‚úÖ %s completada: %.2f%n", operacion, resultado);
            
        } catch (InterruptedException e) {
            System.err.println("‚ùå C√°lculo interrumpido: " + operacion);
        }
    }
    
    public double getResultado() { return resultado; }
    
    public static void main(String[] args) throws InterruptedException {
        // Crear m√∫ltiples operaciones
        CalculadoraAvanzada suma = new CalculadoraAvanzada("suma", 15, 25);
        CalculadoraAvanzada multiplicacion = new CalculadoraAvanzada("multiplicacion", 7, 8);
        CalculadoraAvanzada potencia = new CalculadoraAvanzada("potencia", 2, 10);
        CalculadoraAvanzada raiz = new CalculadoraAvanzada("raiz", 144, 0);
        
        // Ejecutar todas las operaciones EN PARALELO
        Thread[] hilos = {
            new Thread(suma),
            new Thread(multiplicacion),
            new Thread(potencia),
            new Thread(raiz)
        };
        
        // Iniciar todos los hilos
        for (Thread hilo : hilos) {
            hilo.start();
        }
        
        // Esperar que terminen todos
        for (Thread hilo : hilos) {
            hilo.join();
        }
        
        // Mostrar resultados finales
        System.out.println("\nüìä RESULTADOS FINALES:");
        System.out.printf("Suma: %.2f%n", suma.getResultado());
        System.out.printf("Multiplicaci√≥n: %.2f%n", multiplicacion.getResultado());
        System.out.printf("Potencia: %.2f%n", potencia.getResultado());
        System.out.printf("Ra√≠z: %.2f%n", raiz.getResultado());
    }
}
```

**Ahora entiendes completamente qu√© significa `implements Runnable` y por qu√© es tan poderoso en Java para aplicaciones que necesitan ejecutar tareas en paralelo.**

---

### üìù **CONCEPTO 6: Strings inmutables**

Los `String` en Java son objetos inmutables: una vez creado un `String`, su contenido no puede cambiar.

¬øQu√© significa esto en la pr√°ctica?
- Cualquier operaci√≥n que parezca "modificar" un `String` en realidad crea un nuevo objeto `String`.

Ejemplo:
```java
String s = "Java";           // objeto A
String t = s.toUpperCase();   // crea objeto B con "JAVA"; s sigue siendo "Java"
```

Ventajas de la inmutabilidad:
- Seguridad en concurrencia: m√∫ltiples hilos pueden compartir el mismo `String` sin sincronizaci√≥n.
- Caching y rendimiento en lecturas: el valor (y su hash) puede computarse una vez.
- Uso eficiente del String Pool (ver m√°s abajo).

String Pool e `intern()`:
- Literales de `String` se colocan en un pool (permite reutilizar la misma instancia para literales id√©nticos).
- `String.intern()` fuerza que una cadena tenga su versi√≥n canonical en el pool y devuelve esa referencia.

```java
String a = "hola";                // internado por literal
String b = new String("hola");    // objeto distinto en heap
String c = b.intern();              // c referencia la instancia del pool (igual a a)
System.out.println(a == c);         // true
```

Igualdad: `==` vs `equals()`
- `==` compara referencias (misma instancia).
- `equals()` compara contenido del `String` (uso recomendado para comparar textos).

```java
String x = new String("x");
String y = new String("x");
System.out.println(x == y);        // false
System.out.println(x.equals(y));   // true
```

Rendimiento y concatenaci√≥n
- En concatenaciones simples y literales, el compilador optimiza `+` en tiempo de compilaci√≥n.
- En bucles o concatenaciones intensivas, usar `StringBuilder` (no `String`) para evitar crear muchos objetos temporales.

Ejemplo comparativo:
```java
// Ineficiente: crea muchos Strings temporales
String r = "";
for (int i = 0; i < 1000; i++) {
    r += i + ",";
}

// Eficiente: reutiliza el mismo buffer
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i).append(',');
}
String result = sb.toString();
```

Buenas pr√°cticas resumidas
- Usa `StringBuilder` en loops o concatenaciones grandes.
- Usa `equals()` para comparar contenido.
- Aprovecha literales y `intern()` s√≥lo cuando realmente necesites canonicalizar referencias (uso avanzado).
- Evita dependencias en comportamiento hist√≥rico (por ejemplo, detalles de implementaci√≥n de `substring` que cambiaron en versiones antiguas de Java).

---

### üîÑ **CONCEPTO 7: Estructuras de control**

Las estructuras de control permiten alterar el flujo de ejecuci√≥n del programa bas√°ndose en condiciones o repeticiones. Java ofrece estructuras condicionales, de selecci√≥n m√∫ltiple y de repetici√≥n.

#### **ESTRUCTURAS CONDICIONALES**

##### **IF-ELSE - Condicional b√°sica:**
```java
// Forma b√°sica
if (condicion) {
    // Se ejecuta si la condici√≥n es true
    System.out.println("Condici√≥n verdadera");
}

// Con else
if (edad >= 18) {
    System.out.println("Es mayor de edad");
} else {
    System.out.println("Es menor de edad");
}

// Con else if (m√∫ltiples condiciones)
if (nota >= 90) {
    System.out.println("Excelente");
} else if (nota >= 80) {
    System.out.println("Muy bueno");
} else if (nota >= 70) {
    System.out.println("Bueno");
} else if (nota >= 60) {
    System.out.println("Suficiente");
} else {
    System.out.println("Insuficiente");
}
```

**‚ö†Ô∏è Importante en Java:**
```java
// ‚ùå ERROR - Java requiere boolean expl√≠cito (no int como C)
int numero = 5;
if (numero) { ... }  // Error de compilaci√≥n

// ‚úÖ CORRECTO - Comparaci√≥n expl√≠cita
if (numero != 0) { ... }  // OK

// ‚ùå ERROR - Asignaci√≥n en lugar de comparaci√≥n
if (numero = 5) { ... }  // Error de compilaci√≥n

// ‚úÖ CORRECTO - Comparaci√≥n
if (numero == 5) { ... }  // OK
```

##### **Operador ternario (? :):**
```java
// Sintaxis: condici√≥n ? valorSiTrue : valorSiFalse
String resultado = (edad >= 18) ? "Mayor" : "Menor";

// Equivale a:
String resultado;
if (edad >= 18) {
    resultado = "Mayor";
} else {
    resultado = "Menor";
}

// Ejemplos pr√°cticos
int max = (a > b) ? a : b;  // M√°ximo de dos n√∫meros
String mensaje = (saldo > 0) ? "Cuenta positiva" : "Cuenta en n√∫meros rojos";
```

#### **SWITCH - Selecci√≥n m√∫ltiple**

##### **Switch tradicional (Java 8):**
```java
switch (variable) {
    case valor1:
        // C√≥digo para valor1
        break;  // ‚ö†Ô∏è Importante: sin break contin√∫a al siguiente case
    case valor2:
        // C√≥digo para valor2
        break;
    case valor3:
    case valor4:  // M√∫ltiples casos con la misma l√≥gica
        // C√≥digo para valor3 y valor4
        break;
    default:  // Opcional: caso por defecto
        // C√≥digo si no coincide ning√∫n case
        break;
}
```

**Tipos permitidos en switch:**
```java
// ‚úÖ PERMITIDOS en Java 8:
switch (entero) { ... }     // int, byte, short, char
switch (caracter) { ... }   // char
switch (cadena) { ... }     // String (desde Java 7)
switch (enumValue) { ... }  // enum

// ‚ùå NO PERMITIDOS:
switch (numeroLong) { ... }     // long
switch (numeroFloat) { ... }    // float
switch (numeroDouble) { ... }   // double
switch (booleano) { ... }       // boolean
```

**Ejemplos pr√°cticos:**
```java
// Switch con String
switch (dia.toUpperCase()) {
    case "LUNES":
    case "MARTES":
    case "MI√âRCOLES":
    case "JUEVES":
    case "VIERNES":
        System.out.println("D√≠a laboral");
        tipoJornada = "trabajo";
        break;
    case "S√ÅBADO":
    case "DOMINGO":
        System.out.println("Fin de semana");
        tipoJornada = "descanso";
        break;
    default:
        System.out.println("D√≠a no reconocido");
        tipoJornada = "indefinido";
}

// Switch con enum
public enum Estado {
    ACTIVO, INACTIVO, SUSPENDIDO, BLOQUEADO
}

switch (usuario.getEstado()) {
    case ACTIVO:
        permitirAcceso();
        break;
    case INACTIVO:
        mostrarMensajeActivacion();
        break;
    case SUSPENDIDO:
        mostrarMensajeSuspension();
        break;
    case BLOQUEADO:
        denegarAcceso();
        break;
}
```

**‚ö†Ô∏è Cuidado con el fall-through:**
```java
// Comportamiento fall-through (contin√∫a sin break)
int puntos = 0;
switch (nivel) {
    case 1:
        puntos += 10;  // Si nivel = 1, suma 10
    case 2:
        puntos += 20;  // Si nivel = 1 o 2, suma 20
    case 3:
        puntos += 30;  // Si nivel = 1, 2 o 3, suma 30
        break;
}
// Si nivel = 1, puntos = 60 (10+20+30)
// Si nivel = 2, puntos = 50 (20+30)
// Si nivel = 3, puntos = 30
```

#### **BUCLES - Estructuras de repetici√≥n**

##### **FOR - Bucle con contador:**
```java
// Sintaxis b√°sica
for (inicializaci√≥n; condici√≥n; incremento) {
    // C√≥digo a repetir
}

// Ejemplo t√≠pico
for (int i = 0; i < 10; i++) {
    System.out.println("Iteraci√≥n: " + i);
}

// M√∫ltiples variables
for (int i = 0, j = 10; i < j; i++, j--) {
    System.out.println("i = " + i + ", j = " + j);
}

// Bucle decreciente
for (int i = 10; i >= 0; i--) {
    System.out.println("Cuenta regresiva: " + i);
}

// Incremento personalizado
for (int i = 0; i < 100; i += 5) {
    System.out.println("M√∫ltiplo de 5: " + i);
}
```

##### **FOR-EACH (Enhanced For Loop):**
```java
// Para arrays
int[] numeros = {1, 2, 3, 4, 5};
for (int numero : numeros) {
    System.out.println("N√∫mero: " + numero);
}

// Para colecciones
List<String> nombres = Arrays.asList("Ana", "Luis", "Mar√≠a");
for (String nombre : nombres) {
    System.out.println("Nombre: " + nombre);
}

// ‚ö†Ô∏è Limitaci√≥n: no puedes modificar la colecci√≥n durante la iteraci√≥n
List<Integer> lista = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer numero : lista) {
    if (numero % 2 == 0) {
        lista.remove(numero);  // ‚ùå ConcurrentModificationException
    }
}

// ‚úÖ Soluci√≥n: usar Iterator
Iterator<Integer> it = lista.iterator();
while (it.hasNext()) {
    Integer numero = it.next();
    if (numero % 2 == 0) {
        it.remove();  // OK
    }
}
```

##### **WHILE - Bucle con condici√≥n previa:**
```java
// Sintaxis b√°sica
while (condici√≥n) {
    // C√≥digo a repetir
}

// Ejemplo: leer entrada hasta que sea v√°lida
Scanner scanner = new Scanner(System.in);
int numero = 0;
while (numero <= 0) {
    System.out.print("Ingrese un n√∫mero positivo: ");
    numero = scanner.nextInt();
    if (numero <= 0) {
        System.out.println("N√∫mero inv√°lido, intente de nuevo.");
    }
}

// Bucle infinito (cuidado)
while (true) {
    // C√≥digo
    if (condicionSalida) {
        break;  // Salir del bucle
    }
}
```

##### **DO-WHILE - Bucle con condici√≥n posterior:**
```java
// Sintaxis b√°sica
do {
    // C√≥digo a repetir (se ejecuta AL MENOS UNA VEZ)
} while (condici√≥n);

// Ejemplo: men√∫ que se muestra al menos una vez
Scanner scanner = new Scanner(System.in);
int opcion;
do {
    System.out.println("\n=== MEN√ö ===");
    System.out.println("1. Opci√≥n A");
    System.out.println("2. Opci√≥n B");
    System.out.println("3. Salir");
    System.out.print("Seleccione una opci√≥n: ");
    opcion = scanner.nextInt();
    
    switch (opcion) {
        case 1:
            System.out.println("Ejecutando opci√≥n A");
            break;
        case 2:
            System.out.println("Ejecutando opci√≥n B");
            break;
        case 3:
            System.out.println("Saliendo...");
            break;
        default:
            System.out.println("Opci√≥n inv√°lida");
    }
} while (opcion != 3);
```

#### **CONTROL DE FLUJO**

##### **BREAK - Salir de bucles o switch:**
```java
// Break en bucles
for (int i = 0; i < 100; i++) {
    if (i == 50) {
        break;  // Sale del bucle cuando i = 50
    }
    System.out.println(i);
}

// Break con etiquetas (para bucles anidados)
exterior: for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (i * j > 6) {
            break exterior;  // Sale del bucle exterior
        }
        System.out.println("i=" + i + ", j=" + j);
    }
}
```

##### **CONTINUE - Saltar a la siguiente iteraci√≥n:**
```java
// Continue en bucles
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0) {
        continue;  // Salta los n√∫meros pares
    }
    System.out.println("N√∫mero impar: " + i);
}

// Continue con etiquetas
exterior: for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (j == 2) {
            continue exterior;  // Contin√∫a con la siguiente iteraci√≥n del bucle exterior
        }
        System.out.println("i=" + i + ", j=" + j);
    }
}
```

##### **RETURN - Salir de m√©todos:**
```java
public boolean esPrimo(int numero) {
    if (numero <= 1) {
        return false;  // Sale inmediatamente del m√©todo
    }
    
    for (int i = 2; i <= Math.sqrt(numero); i++) {
        if (numero % i == 0) {
            return false;  // Sale inmediatamente si encuentra un divisor
        }
    }
    
    return true;  // Solo llega aqu√≠ si es primo
}
```

#### **PATRONES COMUNES Y MEJORES PR√ÅCTICAS**

##### **1. Validaci√≥n de entrada:**
```java
public static int leerEnteroEnRango(Scanner scanner, int min, int max) {
    int numero;
    do {
        System.out.printf("Ingrese un n√∫mero entre %d y %d: ", min, max);
        while (!scanner.hasNextInt()) {
            System.out.println("Error: debe ingresar un n√∫mero entero.");
            scanner.next(); // Descartar entrada inv√°lida
        }
        numero = scanner.nextInt();
        if (numero < min || numero > max) {
            System.out.printf("Error: el n√∫mero debe estar entre %d y %d.\n", min, max);
        }
    } while (numero < min || numero > max);
    
    return numero;
}
```

##### **2. Procesamiento de arrays:**
```java
// Encontrar el m√°ximo
int[] numeros = {5, 2, 8, 1, 9, 3};
int maximo = numeros[0];
for (int i = 1; i < numeros.length; i++) {
    if (numeros[i] > maximo) {
        maximo = numeros[i];
    }
}

// Contar elementos que cumplen condici√≥n
int contador = 0;
for (int numero : numeros) {
    if (numero % 2 == 0) {
        contador++;
    }
}

// Buscar un elemento
boolean encontrado = false;
int elementoBuscado = 8;
for (int numero : numeros) {
    if (numero == elementoBuscado) {
        encontrado = true;
        break;
    }
}
```

##### **3. Anidaci√≥n de bucles (matrices):**
```java
int[][] matriz = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Recorrer matriz
for (int fila = 0; fila < matriz.length; fila++) {
    for (int columna = 0; columna < matriz[fila].length; columna++) {
        System.out.printf("%d ", matriz[fila][columna]);
    }
    System.out.println(); // Nueva l√≠nea despu√©s de cada fila
}

// Con for-each
for (int[] fila : matriz) {
    for (int elemento : fila) {
        System.out.printf("%d ", elemento);
    }
    System.out.println();
}
```

#### **ERRORES COMUNES Y C√ìMO EVITARLOS**

##### **1. Off-by-one errors:**
```java
// ‚ùå ERROR com√∫n
for (int i = 0; i <= array.length; i++) {  // IndexOutOfBoundsException
    System.out.println(array[i]);
}

// ‚úÖ CORRECTO
for (int i = 0; i < array.length; i++) {
    System.out.println(array[i]);
}
```

##### **2. Bucles infinitos:**
```java
// ‚ùå PELIGROSO
int i = 0;
while (i < 10) {
    System.out.println(i);
    // Falta: i++; ¬°Bucle infinito!
}

// ‚úÖ CORRECTO
int i = 0;
while (i < 10) {
    System.out.println(i);
    i++;
}
```

##### **3. Modificar colecciones durante iteraci√≥n:**
```java
List<String> lista = new ArrayList<>();
lista.add("A");
lista.add("B");
lista.add("C");

// ‚ùå ERROR
for (String elemento : lista) {
    if (elemento.equals("B")) {
        lista.remove(elemento);  // ConcurrentModificationException
    }
}

// ‚úÖ CORRECTO - usar Iterator
Iterator<String> it = lista.iterator();
while (it.hasNext()) {
    String elemento = it.next();
    if (elemento.equals("B")) {
        it.remove();
    }
}
```

---

### üìä **CONCEPTO 8: Arrays**
Arrays en Java son objetos de tama√±o fijo que almacenan elementos del mismo tipo y exponen la propiedad `.length` para conocer su tama√±o.

Caracter√≠sticas clave:
- Tama√±o fijo: una vez creado, no cambia su longitud.
- √çndices base 0: el primer elemento est√° en la posici√≥n 0 y el √∫ltimo en `length - 1`.
- Pueden ser de tipos primitivos (p. ej. `int[]`) o de referencia (p. ej. `String[]`).
- Son objetos y, por tanto, se almacenan en el heap.

Declaraci√≥n y creaci√≥n:
```java
// Declarar
int[] a;            // variable que puede apuntar a un array de int

// Crear con tama√±o
a = new int[5];     // [0,0,0,0,0]

// Crear e inicializar
int[] b = {1, 2, 3};
String[] names = new String[]{"Ana", "Luis"};
```

Acceso y modificaci√≥n:
```java
int x = b[0];       // leer (1)
b[1] = 42;          // asignar
int len = b.length; // obtener tama√±o
```

Recorrido:
```java
// for cl√°sico
for (int i = 0; i < b.length; i++) {
    System.out.println(b[i]);
}

// for-each (m√°s legible, no permite conocer el √≠ndice directamente)
for (int v : b) {
    System.out.println(v);
}
```

Arrays multidimensionales:
```java
int[][] matriz = new int[3][2];     // matriz 3x2 (todas las filas mismo tama√±o)
int[][] jagged = new int[3][];      // filas con tama√±os distintos
jagged[0] = new int[2];
jagged[1] = new int[4];
```

API y utilidades importantes:

- `java.util.Arrays` (m√©todos clave):
    - `Arrays.toString(array)` / `Arrays.deepToString(array)` ‚Äî representaci√≥n legible de arrays (deep para arrays anidados).
    - `Arrays.sort(array)` ‚Äî ordena in-place en tiempo O(n log n).
    - `Arrays.parallelSort(array)` ‚Äî ordena en paralelo aprovechando m√∫ltiples cores (√∫til para arrays grandes).
    - `Arrays.binarySearch(array, key)` ‚Äî b√∫squeda binaria (requiere array previamente ordenado).
    - `Arrays.copyOf(array, newLength)` / `Arrays.copyOfRange(array, from, to)` ‚Äî copiar y redimensionar de forma segura.
    - `Arrays.fill(array, value)` ‚Äî rellena todo el array con un √∫nico valor (√∫til para inicializar/limpiar).
    - `Arrays.equals(a,b)` / `Arrays.deepEquals(a,b)` ‚Äî comparaci√≥n por contenido.
    - `Arrays.asList(array)` ‚Äî crea una vista fija tipo `List` sobre el array; la lista resultante es de tama√±o fijo y refleja cambios en el array.
    - `Arrays.setAll(array, i -> f(i))` / `Arrays.parallelSetAll(array, i -> f(i))` ‚Äî inicializaci√≥n mediante funci√≥n (Java 8+).
    - `Arrays.mismatch(a, b)` (Java 9+) ‚Äî devuelve el primer √≠ndice donde difieren o -1 si son iguales.

- `System.arraycopy(src, srcPos, dest, destPos, length)` ‚Äî copia de bloques entre arrays muy eficiente (mejor rendimiento que copiar elemento a elemento en Java puro).

- Otras utilidades relacionadas:
    - `Collections` y `List` (por ejemplo, `new ArrayList<>(Arrays.asList(array))` para obtener una lista mutable).
    - `java.util.concurrent` collections para uso concurrente (p. ej. `CopyOnWriteArrayList`) si m√∫ltiples hilos modifican la estructura.

Streams y procesamiento funcional (resumen):

Un Stream en Java representa una secuencia de elementos sobre la cual podemos aplicar operaciones funcionales (map, filter, reduce, collect). Los Streams permiten escribir pipelines declarativos y pueden ser secuenciales o paralelos.

- Caracter√≠sticas clave:
    - Operaciones intermedias (map, filter, sorted) son perezosas y devuelven otro Stream.
    - Operaciones terminales (forEach, collect, reduce, sum) disparan la ejecuci√≥n y producen un resultado o efecto lateral.
    - Los Streams no almacenan datos: son una vista computacional sobre una fuente (arrays, colecciones, I/O).

- Tipos de Streams:
    - `Stream<T>` para referencias.
    - `IntStream`, `LongStream`, `DoubleStream` para tipos primitivos (evitan boxing).

- Ejemplo b√°sico:
```java
int[] nums = {1,2,3,4,5};
int sum = Arrays.stream(nums)
                                .filter(n -> n % 2 == 0)
                                .map(n -> n * 2)
                                .sum();
```

- Ejemplo con objetos y collector:
```java
String[] names = {"Ana", "Luis", "Mar√≠a"};
List<String> upper = Arrays.stream(names)\n+        .map(String::toUpperCase)
        .filter(s -> s.length() > 3)
        .collect(Collectors.toList());
```

- Paralelismo:
    - `Arrays.stream(array).parallel()` o `parallelStream()` en colecciones; √∫til para operaciones CPU-bound en arrays grandes, pero cuidado con efectos laterales y overhead de particionado.

Consideraciones de rendimiento:
- Streams pueden ser legibles y concisos; para hot paths donde la alocaci√≥n y boxing son cr√≠ticos, usa `IntStream`/`LongStream` o APIs de arrays (System.arraycopy, Arrays methods).

Ejemplos:
```java
int[] c = Arrays.copyOf(b, 5);               // copia y extiende con ceros
System.arraycopy(b, 0, c, 0, Math.min(b.length, c.length));
Arrays.sort(c);                              // ordenar
int idx = Arrays.binarySearch(c, 42);        // buscar (array debe estar ordenado)
System.out.println(Arrays.toString(c));     // representaci√≥n legible

// Rellenar con un valor
Arrays.fill(c, 0);

// Comparar arrays
int[] x = {1,2,3};
int[] y = {1,2,3};
System.out.println(Arrays.equals(x,y)); // true

// Convertir a stream y sumar
int sum = Arrays.stream(c).sum();
```


Errores comunes:
- Off-by-one: usar `i < array.length` y no `<=`.
- IndexOutOfBounds: acceder a √≠ndices negativos o >= length.
- Intentar cambiar el tama√±o del array (usar `ArrayList` o crear uno nuevo con `Arrays.copyOf`).
- Modificar elementos mientras iteras con for-each (usa √≠ndices o `List` cuando debas eliminar).

#### Vaciar o reutilizar un array ya inicializado

Una vez que un array ha sido creado e inicializado con valores, no existe un m√©todo "vaciar" que cambie su longitud; las estrategias dependen del objetivo:

1) Reutilizar el mismo array y sobrescribir valores
```java
Arrays.fill(arr, 0);          // para tipos primitivos: rellena con el valor por defecto/indicado
Arrays.fill(objArr, null);    // para arrays de referencia: establece todas las referencias a null
```
Ventaja: mantiene la misma referencia (√∫til si otros objetos mantienen punteros al array).

2) Crear un nuevo array y reasignar la referencia
```java
arr = new int[originalLength];   // crea un array vac√≠o (con ceros)
```
Ventaja: sencillo y claro; cualquier referencia antigua seguir√° apuntando al array previo.

3) Mantener un contador l√≥gico de elementos (simular una 'longitud' variable)
```java
int size = 0;          // n√∫mero de elementos v√°lidos en el array
arr[size++] = value;   // a√±adir
// 'vaciar' l√≥gicamente: size = 0;
```
Ventaja: evita reallocs constantes; patr√≥n √∫til en estructuras de alto rendimiento.

4) Usar `Arrays.copyOf` para truncar o expandir
```java
arr = Arrays.copyOf(arr, newLength);
```
Esto crea un nuevo array con la longitud indicada y copia los elementos hasta el nuevo tama√±o.

Consideraciones sobre referencias y concurrencia:
- Si otras partes del c√≥digo apuntan al mismo array, reasignar la variable local no afecta a esas referencias.
- Si necesitas invalidar contenido por seguridad (por ejemplo, limpiar datos sensibles), usa `Arrays.fill(objArr, null)` o sobreescribe con valores neutros.
- Para entornos concurrentes, sincroniza cuando m√∫ltiples hilos lean/escriban el array o usa estructuras concurrentes (p. ej. `CopyOnWriteArrayList`).

Rendimiento y recomendaciones:
- Para colecciones din√°micas, prefiere `ArrayList<T>` en lugar de arrays si necesitas tama√±o variable.
- Para operaciones intensivas de lectura/escritura indexada, los arrays son muy eficientes (menos overhead que `ArrayList`).
- Evita crear arrays muy grandes sin control de memoria; usa streams o procesamiento por bloques cuando sea necesario.

Buenas pr√°cticas:
- Usa `Arrays.asList()` cuando necesites una vista fija basada en un array (no soporta operaciones de tama√±o).
- Prefiere `Arrays.copyOf()` o `System.arraycopy()` para copiar en vez de bucles manuales por claridad y rendimiento.
- Documenta si un array puede contener `null` para tipos de referencia.

---

### üéØ **CONCEPTO 9: Tipos de datos (primitivos y wrappers)**
Los tipos de datos en Java se dividen en primitivos y tipos de referencia (objetos). Los primitivos son m√°s eficientes en memoria y rendimiento; las clases wrapper permiten tratarlos como objetos (necesario en colecciones y APIs que requieren objetos).

Tabla resumen de primitivos:

| Tipo | Tama√±o | Rango | Valor por defecto | Wrapper |
|------|--------|-------|-------------------|---------|
| byte | 8 bits | -128 a 127 | 0 | `Byte` |
| short | 16 bits | -32,768 a 32,767 | 0 | `Short` |
| int | 32 bits | -2,147,483,648 a 2,147,483,647 | 0 | `Integer` |
| long | 64 bits | -9.22e18 a 9.22e18 | 0L | `Long` |
| float | 32 bits | ¬±3.4e38 (approx) | 0.0f | `Float` |
| double | 64 bits | ¬±1.7e308 (approx) | 0.0d | `Double` |
| boolean | 1 bit (pr√°ctico) | true/false | false | `Boolean` |
| char | 16 bits | ' ' (0..65535) | '\u0000' | `Character` |

Wrappers y autoboxing/unboxing:
- Desde Java 5 existe autoboxing: el compilador convierte autom√°ticamente entre primitivos y wrappers cuando es necesario.
    ```java
    Integer i = 42;     // autoboxing: int -> Integer
    int j = i;          // unboxing: Integer -> int
    ```

Peligros y puntos a considerar:
- Performance: autoboxing crea objetos; en bucles intensivos puede afectar rendimiento y memoria.
- `==` con wrappers compara referencias; para comparar valores usa `equals()` o unboxing.
    ```java
    Integer a = 127, b = 127;  // puede estar cacheado
    Integer c = 128, d = 128;  // no cacheado
    System.out.println(a == b); // true (cache)
    System.out.println(c == d); // false
    System.out.println(c.equals(d)); // true
    ```
- NullPointerException: al hacer unboxing de un `null` (Integer i = null; int x = i;) se lanza NPE.

Cu√°ndo usar cada uno:
- Usa primitivos (`int`, `double`, etc.) para variables locales, contadores y c√°lculos num√©ricos intensivos.
- Usa wrappers cuando necesites almacenar en colecciones (`List<Integer>`) o cuando una API requiera objetos.
- Para flags booleanas en objetos, wrapper `Boolean` permite `null` como estado "no especificado".

Conversi√≥n entre tipos:
- Conversi√≥n impl√≠cita: se permite entre tipos compatibles (p. ej. `int` -> `long`).
- Conversi√≥n expl√≠cita (casting) necesaria para p√©rdidas de precisi√≥n: `(int) 3.14`.

Operaciones aritm√©ticas y precauciones:
- Cuidado con overflow en enteros; usa `long` cuando esperes valores grandes.
- Para operaciones de precisi√≥n decimal usa `BigDecimal` en lugar de `double` cuando la exactitud es cr√≠tica (finanzas).

Ejemplos pr√°cticos:
```java
int sum = 0;
for (int i = 0; i < 1_000_000; i++) sum += i; // eficiente

List<Integer> list = new ArrayList<>();
list.add(1); // autoboxing: int -> Integer
```

---

### üìù **CONCEPTO 10: Reglas para variables, clases y palabras reservadas**

Variables
- Formato: camelCase (lowerCamelCase)
    - Ejemplos: `nombreUsuario`, `contadorTotal`, `estaActivo`
    - Variables booleanas: prefijos `es/esta/tiene` (p.ej. `estaVacio`, `tieneSiguiente`).
    - Constantes: `static final` en UPPER_CASE con guiones bajos, p.ej. `MAXIMO_INTENTOS`.
    - Reglas pr√°cticas:
        - No uses abreviaturas no obvias.
        - Para contadores temporales en bucles est√° bien `i`, `j`, `k`.
        - Evita nombres que oculten el prop√≥sito: `temporal` o `tmp` solo cuando es claramente temporal.

Clases
- Formato: PascalCase (UpperCamelCase)
    - Ejemplos: `Cliente`, `ServicioPedidos`, `ManejadorSolicitudHttp`.
    - Deben ser sustantivos o sustantivo+complemento (no verbos): `GeneradorReporte` (bien), no `generarReporte`.
    - Evita colisiones con clases est√°ndar (`String`, `List`, etc.).

Palabras reservadas (no usables como identificadores)
- Java reserva palabras clave que no pueden emplearse como nombres de variables, clases o m√©todos. Entre ellas:

```
abstract  assert      boolean   break    byte
case      catch       char      class    const
continue  default     do        double   else
enum      extends     final     finally  float
for       goto        if        implements import
instanceof int        interface long     native
new       package     private   protected public
return    short       static    strictfp synchronized
super     switch      this      throw    throws
transient try         void      volatile while
```

- Adem√°s, literales `true`, `false` y `null` no son v√°lidos como identificadores.

Regla pr√°ctica: elige nombres descriptivos y consistentes; si dudas, prefiere claridad. Mant√©n una gu√≠a de estilo del proyecto y aplica herramientas autom√°ticas (Checkstyle) si quieres forzar reglas en CI.

---

### üí¨ **CONCEPTO 11: Tipos de comentarios**

Java ofrece tres tipos principales de comentarios, cada uno con prop√≥sitos espec√≠ficos y mejores pr√°cticas asociadas. Los comentarios son fundamentales para la documentaci√≥n del c√≥digo y la comunicaci√≥n entre desarrolladores.

#### **1. Comentarios de l√≠nea simple (`//`)**

Los comentarios de l√≠nea simple se extienden desde `//` hasta el final de la l√≠nea y son ideales para explicaciones breves.

##### **Usos principales:**
```java
public class EjemploComentarios {
    // Variable para almacenar el contador principal
    private int contador = 0;
    
    public void metodoEjemplo() {
        contador++; // Incrementar contador despu√©s de cada operaci√≥n
        
        // TODO: Implementar validaci√≥n de rango
        if (contador > 100) {
            reset(); // Reiniciar si supera el l√≠mite
        }
        
        // FIXME: Este algoritmo es O(n¬≤), optimizar
        for (int i = 0; i < contador; i++) {
            // Procesamiento interno
            procesarElemento(i);
        }
    }
}
```

##### **Etiquetas especiales comunes:**
```java
// TODO: Funcionalidad pendiente de implementar
// FIXME: Error conocido que necesita correcci√≥n
// HACK: Soluci√≥n temporal, revisar en futuras versiones
// NOTE: Informaci√≥n importante para mantener
// WARNING: C√≥digo cr√≠tico, modificar con cuidado
// OPTIMIZE: Oportunidad de mejora de rendimiento
// REVIEW: C√≥digo que necesita revisi√≥n por pares
```

#### **2. Comentarios multil√≠nea (`/* */`)**

Los comentarios multil√≠nea se extienden desde `/*` hasta `*/` y pueden abarcar m√∫ltiples l√≠neas. Son √∫tiles para explicaciones extensas o para comentar bloques de c√≥digo temporalmente.

##### **Formato recomendado:**
```java
/*
 * Este m√©todo implementa el algoritmo de ordenamiento QuickSort
 * optimizado para arrays de enteros.
 * 
 * Complejidad temporal: O(n log n) promedio, O(n¬≤) peor caso
 * Complejidad espacial: O(log n) debido a la recursi√≥n
 * 
 * @param arr Array a ordenar
 * @param low √çndice inferior del rango
 * @param high √çndice superior del rango
 */
public void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

##### **Comentar c√≥digo temporalmente:**
```java
public void procesarDatos() {
    // Versi√≥n nueva (en desarrollo)
    procesamientoOptimizado();
    
    /*
    // Versi√≥n anterior (comentada temporalmente)
    for (int i = 0; i < datos.length; i++) {
        if (datos[i] != null) {
            procesarItem(datos[i]);
        }
    }
    */
}
```

##### **Comentarios de bloque para licencias/headers:**
```java
/*
 * Copyright (c) 2025 Mi Empresa
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */
package com.miempresa.proyecto;
```

#### **3. Comentarios JavaDoc (`/** */`)**

Los comentarios JavaDoc son una forma especializada de comentarios multil√≠nea que generan documentaci√≥n HTML autom√°ticamente. Siguen el formato `/** */` y utilizan etiquetas especiales.

##### **Estructura b√°sica:**
```java
/**
 * Breve descripci√≥n del m√©todo, clase o campo.
 * 
 * Descripci√≥n m√°s detallada que puede incluir m√∫ltiples p√°rrafos,
 * ejemplos de uso, consideraciones especiales, etc.
 * 
 * @param nombreParametro descripci√≥n del par√°metro
 * @return descripci√≥n de lo que retorna el m√©todo
 * @throws TipoExcepcion cu√°ndo y por qu√© se lanza la excepci√≥n
 * @since versi√≥n en que se agreg√≥
 * @author nombre del autor
 * @deprecated si el m√©todo est√° obsoleto
 */
```

##### **Ejemplo completo de clase documentada:**
```java
/**
 * Representa una cuenta bancaria b√°sica con operaciones de dep√≥sito,
 * retiro y consulta de saldo.
 * 
 * <p>Esta clase proporciona las funcionalidades esenciales para
 * manejar una cuenta bancaria, incluyendo validaciones de seguridad
 * y registro de transacciones.</p>
 * 
 * <p><strong>Ejemplo de uso:</strong></p>
 * <pre>
 * CuentaBancaria cuenta = new CuentaBancaria("123456789", 1000.0);
 * cuenta.depositar(500.0);
 * cuenta.retirar(200.0);
 * System.out.println("Saldo: " + cuenta.getSaldo()); // Saldo: 1300.0
 * </pre>
 * 
 * @author Juan P√©rez
 * @version 2.1
 * @since 1.0
 */
public class CuentaBancaria {
    /**
     * N√∫mero √∫nico que identifica la cuenta bancaria.
     * 
     * @since 1.0
     */
    private final String numeroCuenta;
    
    /**
     * Saldo actual de la cuenta en la moneda base.
     * 
     * @since 1.0
     */
    private double saldo;
    
    /**
     * Crea una nueva cuenta bancaria con el n√∫mero y saldo inicial especificados.
     * 
     * @param numeroCuenta el n√∫mero √∫nico de la cuenta (no puede ser null o vac√≠o)
     * @param saldoInicial el saldo inicial de la cuenta (debe ser >= 0)
     * @throws IllegalArgumentException si el n√∫mero de cuenta es inv√°lido
     * @throws IllegalArgumentException si el saldo inicial es negativo
     * @since 1.0
     */
    public CuentaBancaria(String numeroCuenta, double saldoInicial) {
        if (numeroCuenta == null || numeroCuenta.trim().isEmpty()) {
            throw new IllegalArgumentException("El n√∫mero de cuenta no puede estar vac√≠o");
        }
        if (saldoInicial < 0) {
            throw new IllegalArgumentException("El saldo inicial no puede ser negativo");
        }
        
        this.numeroCuenta = numeroCuenta;
        this.saldo = saldoInicial;
    }
    
    /**
     * Deposita una cantidad espec√≠fica en la cuenta.
     * 
     * <p>El monto a depositar debe ser positivo. Esta operaci√≥n
     * incrementa el saldo actual de la cuenta.</p>
     * 
     * @param monto la cantidad a depositar (debe ser > 0)
     * @return el nuevo saldo despu√©s del dep√≥sito
     * @throws IllegalArgumentException si el monto es menor o igual a cero
     * @since 1.0
     */
    public double depositar(double monto) {
        if (monto <= 0) {
            throw new IllegalArgumentException("El monto a depositar debe ser positivo");
        }
        
        saldo += monto;
        return saldo;
    }
    
    /**
     * Retira una cantidad espec√≠fica de la cuenta si hay fondos suficientes.
     * 
     * @param monto la cantidad a retirar (debe ser > 0)
     * @return el nuevo saldo despu√©s del retiro
     * @throws IllegalArgumentException si el monto es menor o igual a cero
     * @throws IllegalStateException si no hay fondos suficientes
     * @since 1.0
     */
    public double retirar(double monto) {
        if (monto <= 0) {
            throw new IllegalArgumentException("El monto a retirar debe ser positivo");
        }
        if (monto > saldo) {
            throw new IllegalStateException("Fondos insuficientes");
        }
        
        saldo -= monto;
        return saldo;
    }
    
    /**
     * Obtiene el saldo actual de la cuenta.
     * 
     * @return el saldo actual de la cuenta
     * @since 1.0
     */
    public double getSaldo() {
        return saldo;
    }
    
    /**
     * Obtiene el n√∫mero de cuenta.
     * 
     * @return el n√∫mero √∫nico de la cuenta
     * @since 1.0
     */
    public String getNumeroCuenta() {
        return numeroCuenta;
    }
}
```

#### **Etiquetas JavaDoc m√°s utilizadas**

##### **Para m√©todos:**
```java
/**
 * @param nombreParam descripci√≥n del par√°metro
 * @return descripci√≥n de lo que retorna
 * @throws ExceptionType cu√°ndo se lanza esta excepci√≥n
 * @see ClaseRelacionada#metodoRelacionado()
 * @since versi√≥n en que se agreg√≥
 * @deprecated desde versi√≥n X.X, usar {@link #nuevoMetodo()} en su lugar
 */
```

##### **Para clases:**
```java
/**
 * @author Nombre del Autor
 * @version 1.2.3
 * @since 1.0
 * @see ClaseRelacionada
 * @deprecated desde versi√≥n 2.0, usar {@link NuevaClase} en su lugar
 */
```

##### **Para campos:**
```java
/**
 * @since versi√≥n en que se agreg√≥
 * @deprecated si est√° obsoleto
 */
```

#### **Etiquetas HTML permitidas en JavaDoc**

JavaDoc permite ciertas etiquetas HTML para formatear la documentaci√≥n:

```java
/**
 * <p>Este es un p√°rrafo separado.</p>
 * 
 * <ul>
 * <li>Primer elemento de lista</li>
 * <li>Segundo elemento de lista</li>
 * </ul>
 * 
 * <ol>
 * <li>Primer elemento numerado</li>
 * <li>Segundo elemento numerado</li>
 * </ol>
 * 
 * <pre>
 * // Ejemplo de c√≥digo formateado
 * int resultado = calcular(10, 20);
 * System.out.println(resultado);
 * </pre>
 * 
 * <code>variable</code> - para resaltar c√≥digo inline
 * <strong>texto importante</strong> - para texto en negritas
 * <em>texto enfatizado</em> - para texto en cursiva
 * 
 * <table>
 * <tr><th>Par√°metro</th><th>Tipo</th><th>Descripci√≥n</th></tr>
 * <tr><td>x</td><td>int</td><td>Primer operando</td></tr>
 * <tr><td>y</td><td>int</td><td>Segundo operando</td></tr>
 * </table>
 */
```

#### **Referencias cruzadas en JavaDoc**

```java
/**
 * Este m√©todo utiliza el algoritmo implementado en {@link #ordenarArray(int[])}.
 * 
 * Para m√°s informaci√≥n sobre ordenamiento, consultar:
 * {@link java.util.Arrays#sort(int[])}
 * 
 * @see #metodoRelacionado()
 * @see OtraClase#otroMetodo()
 * @see <a href="https://docs.oracle.com/javase/8/docs/api/">Java 8 API</a>
 */
```

#### **Generaci√≥n de documentaci√≥n**

##### **Comando b√°sico:**
```bash
# Generar documentaci√≥n para todos los archivos Java
javadoc *.java

# Generar en directorio espec√≠fico
javadoc -d docs *.java

# Incluir informaci√≥n de autor y versi√≥n
javadoc -d docs -author -version *.java

# Para paquetes espec√≠ficos
javadoc -d docs -sourcepath src com.miempresa.proyecto
```

##### **Opciones avanzadas:**
```bash
# Documentaci√≥n completa con enlaces a JDK
javadoc -d docs \
        -author \
        -version \
        -link https://docs.oracle.com/javase/8/docs/api/ \
        -windowtitle "Mi Proyecto API" \
        -doctitle "Mi Proyecto Documentation" \
        -header "<b>Mi Proyecto v1.0</b>" \
        -footer "<i>Copyright 2025 Mi Empresa</i>" \
        *.java
```

#### **Mejores pr√°cticas para comentarios**

##### **‚úÖ Qu√© hacer:**
```java
// ‚úÖ Explica el "por qu√©", no el "qu√©"
// Usar cach√© para mejorar rendimiento en consultas frecuentes
Map<String, Object> cache = new HashMap<>();

// ‚úÖ Documenta decisiones de dise√±o importantes
/**
 * Implementa lazy loading para optimizar el uso de memoria.
 * Los datos se cargan solo cuando se acceden por primera vez.
 */
private List<String> datosLazy;

// ‚úÖ Explica algoritmos complejos
/**
 * Implementa el algoritmo de Dijkstra para encontrar el camino m√°s corto.
 * Complejidad: O((V + E) log V) donde V = v√©rtices, E = aristas
 */
public List<Node> encontrarCaminoMasCorto(Node origen, Node destino) {
    // Implementaci√≥n...
}

// ‚úÖ Documenta precondiciones y postcondiciones
/**
 * @param array debe estar ordenado ascendentemente
 * @return √≠ndice del elemento o -1 si no se encuentra
 * @throws IllegalArgumentException si el array es null
 */
public int busquedaBinaria(int[] array, int elemento) {
    // Implementaci√≥n...
}
```

##### **‚ùå Qu√© evitar:**
```java
// ‚ùå Comentarios obvios (ruido)
int contador = 0; // Inicializar contador en 0

// ‚ùå Comentarios desactualizados
/**
 * Retorna el nombre del usuario
 * @return el nombre como String
 */
public int getUserId() { // M√©todo retorna int, no String!
    return this.userId;
}

// ‚ùå Comentarios que duplican el c√≥digo
// Incrementar i en 1
i++;

// ‚ùå Comentarios largos para c√≥digo simple
/**
 * Este m√©todo suma dos n√∫meros enteros utilizando
 * el operador de suma aritm√©tica b√°sica implementado
 * en el procesador de la m√°quina virtual de Java
 * para realizar la operaci√≥n matem√°tica fundamental...
 */
public int sumar(int a, int b) {
    return a + b; // Un simple return bastar√≠a sin tanto comentario
}
```

#### **Comentarios para diferentes audiencias**

##### **Para desarrolladores del equipo:**
```java
// TEAM: Este workaround es temporal hasta que el API v2 est√© disponible
// PERFORMANCE: Este m√©todo se llama frecuentemente, optimizar si es posible
// SECURITY: Validaci√≥n adicional requerida por auditor√≠a de seguridad
```

##### **Para mantenimiento futuro:**
```java
/**
 * IMPORTANTE: Este m√©todo modifica el estado global de la aplicaci√≥n.
 * Cualquier cambio aqu√≠ debe coordinarse con el equipo de arquitectura.
 * 
 * √öltima modificaci√≥n: 2025-08-26 por Juan P√©rez
 * Motivo: Optimizaci√≥n de memoria seg√∫n ticket #2347
 */
```

##### **Para usuarios de la API:**
```java
/**
 * <h3>Uso t√≠pico:</h3>
 * <pre>
 * // Crear instancia
 * ProcessorService processor = new ProcessorService();
 * 
 * // Configurar opciones
 * processor.setOption("timeout", 5000);
 * processor.setOption("retries", 3);
 * 
 * // Procesar datos
 * Result result = processor.process(inputData);
 * </pre>
 * 
 * <h3>Consideraciones importantes:</h3>
 * <ul>
 * <li>Este m√©todo es thread-safe</li>
 * <li>El timeout predeterminado es 30 segundos</li>
 * <li>Se recomienda reutilizar instancias para mejor rendimiento</li>
 * </ul>
 */
```

Los comentarios efectivos mejoran significativamente la mantenibilidad del c√≥digo y facilitan la colaboraci√≥n en equipos de desarrollo. El uso apropiado de cada tipo de comentario seg√∫n el contexto es clave para una documentaci√≥n de calidad.

---

### ‚ö° **CONCEPTO 12: Paso de par√°metros**

    Java pasa por valor; las referencias a objetos se copian (no se pasa un puntero manipulable externamente).

    ---

    ## Pr√≥ximos pasos

    1) `1.2 Variables y Tipos de Datos`
    2) `2.1 Operadores`
    3) `2.2 Estructuras de Control (avanzado)`

    ---

    Nota: la copia completa anterior se guard√≥ en `README_BACKUP.md` antes de la limpieza.

| Lenguaje | Punto de entrada |
|----------|------------------|
| **Java** | `public static void main(String[] args)` |
| **C/C++** | `int main()` o `int main(int argc, char* argv[])` |
| **Python** | `if __name__ == "__main__":` |
| **JavaScript** | No hay punto de entrada fijo |
| **C#** | `static void Main(string[] args)` |

---

### üö® **CONCEPTO 13: Peculiaridades y diferencias**

#### 1. No hay punteros expl√≠citos:
```java
// ‚ùå NO existe en Java:
int* ptr = &variable;
ptr++;

// ‚úÖ Solo referencias:
String ref = "Hola";
// No hay aritm√©tica de referencias
```

#### 2. Garbage Collection autom√°tico:
```java
// ‚ùå NO necesario en Java:
Object obj = malloc(sizeof(Object));
free(obj);

// ‚úÖ Autom√°tico:
Object obj = new Object();  // Se libera autom√°ticamente
```

#### 3. Array.length es atributo:
```java
int[] array = {1, 2, 3};

// ‚úÖ CORRECTO:
int size = array.length;    // Atributo (sin par√©ntesis)

// ‚ùå INCORRECTO:
int size = array.length();  // Error: no es m√©todo
```

#### 4. Boolean es tipo espec√≠fico:
```java
// ‚ùå NO funciona (como en C):
int flag = 1;
if (flag) { ... }  // Error: incompatible types

// ‚úÖ CORRECTO:
boolean flag = true;
if (flag) { ... }  // OK
```

---

## üéØ RESUMEN DE CONCEPTOS CLAVE

### ‚úÖ **Lo que DEBES recordar:**

1. **M√©todo main espec√≠fico**: `public static void main(String[] args)`
2. **Todo en clases**: No hay funciones globales
3. **Case sensitive**: Java distingue may√∫sculas/min√∫sculas
4. **Fuertemente tipado**: Declaraci√≥n expl√≠cita de tipos
5. **Bytecode portable**: "Write Once, Run Anywhere"
6. **Strings inmutables**: Cada "modificaci√≥n" crea nuevo objeto
7. **Autoboxing autom√°tico**: Conversi√≥n primitivo ‚Üî wrapper class
8. **Arrays son objetos**: Con atributo `.length`
9. **Pool de strings**: Optimizaci√≥n autom√°tica de memoria
10. **Paso por valor**: Siempre se pasan copias

### ‚ùå **Errores comunes a evitar:**

1. Usar `==` para comparar Strings ‚Üí Usar `.equals()`
2. Concatenar strings en loops ‚Üí Usar `StringBuilder`
3. Confundir `array.length` con `array.length()`
4. Olvidar `break` en `switch` statements
5. Intentar usar int como boolean en condiciones
6. No validar arrays/referencias antes de usar (NullPointerException)

---

## üìã **CHECKLIST DE DOMINIO**

### Nivel B√°sico ‚≠ê
- [ ] Puedo escribir un programa Java b√°sico sin ayuda
- [ ] Entiendo por qu√© todo debe estar en una clase
- [ ] S√© compilar y ejecutar desde l√≠nea de comandos
- [ ] Comprendo la diferencia entre primitivos y objetos

### Nivel Intermedio ‚≠ê‚≠ê
- [ ] Entiendo la diferencia entre Stack y Heap
- [ ] S√© cu√°ndo usar StringBuilder vs concatenaci√≥n simple
- [ ] Comprendo el autoboxing/unboxing
- [ ] Puedo explicar por qu√© los Strings son inmutables

### Nivel Avanzado ‚≠ê‚≠ê‚≠ê
- [ ] Entiendo el pool de strings y sus implicaciones
- [ ] Conozco las trampas del Integer cache
- [ ] Puedo explicar c√≥mo funciona el paso de par√°metros
- [ ] Domino las diferencias con otros lenguajes de programaci√≥n

---

## üîó **RECURSOS ADICIONALES**

### Documentaci√≥n Oficial:
- [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/)
- [Java SE 8 API Documentation](https://docs.oracle.com/javase/8/docs/api/)

### Herramientas:
- [Oracle JDK](https://www.oracle.com/java/technologies/downloads/)
- [OpenJDK](https://openjdk.java.net/)
- [IntelliJ IDEA](https://www.jetbrains.com/idea/)
- [Eclipse IDE](https://www.eclipse.org/)

---

## üöÄ **PROYECTO INTEGRADOR: SISTEMA DE GESTI√ìN DE BIBLIOTECA**

### **Objetivo del proyecto:**

Crear un sistema completo que integre todos los conceptos fundamentales aprendidos: entrada/salida, variables est√°ticas vs instancia, case sensitivity, strings inmutables, estructuras de control, arrays y tipos de datos.

### **Funcionalidades a implementar:**

1. **Gesti√≥n de libros** (variables est√°ticas vs instancia)
2. **Sistema de usuarios** (arrays y strings)
3. **Interfaz de consola** (System.out con formato)
4. **Validaciones** (case sensitivity y tipos de datos)
5. **Reportes estad√≠sticos** (estructuras de control)

### **Implementaci√≥n completa:**

```java
import java.util.Scanner;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

// Clase principal del sistema
public class SistemaBiblioteca {
    // Variables est√°ticas - informaci√≥n global del sistema
    private static final String NOMBRE_BIBLIOTECA = "Biblioteca Central Java";
    private static final String VERSION_SISTEMA = "v2.0";
    private static final int CAPACIDAD_MAXIMA = 1000;
    private static int totalLibrosRegistrados = 0;
    private static int totalUsuariosRegistrados = 0;
    
    // Arrays para almacenar datos
    private static Libro[] inventarioLibros = new Libro[CAPACIDAD_MAXIMA];
    private static Usuario[] listaUsuarios = new Usuario[CAPACIDAD_MAXIMA];
    
    // Scanner global para entrada de datos
    private static Scanner scanner = new Scanner(System.in);
    
    public static void main(String[] args) {
        mostrarBienvenida();
        inicializarDatosDemo();
        
        boolean sistemaActivo = true;
        while (sistemaActivo) {
            mostrarMenuPrincipal();
            int opcion = leerOpcionMenu();
            
            switch (opcion) {
                case 1:
                    gestionarLibros();
                    break;
                case 2:
                    gestionarUsuarios();
                    break;
                case 3:
                    realizarPrestamo();
                    break;
                case 4:
                    generarReportes();
                    break;
                case 5:
                    mostrarEstadisticasGlobales();
                    break;
                case 0:
                    sistemaActivo = false;
                    mostrarDespedida();
                    break;
                default:
                    System.err.println("‚ùå Opci√≥n inv√°lida. Intente nuevamente.");
            }
            
            if (sistemaActivo) {
                System.out.println("\nPresione Enter para continuar...");
                scanner.nextLine();
            }
        }
        
        scanner.close();
    }
    
    // M√©todo est√°tico para mostrar bienvenida
    private static void mostrarBienvenida() {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.printf("‚ïë  %s%-38s%s  ‚ïë%n", "üèõÔ∏è  ", NOMBRE_BIBLIOTECA, " üìö");
        System.out.printf("‚ïë  %-58s  ‚ïë%n", "Sistema de Gesti√≥n Integral " + VERSION_SISTEMA);
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.println("‚ïë  Desarrollado como proyecto integrador de Java 8            ‚ïë");
        System.out.println("‚ïë  Integrando conceptos fundamentales del lenguaje            ‚ïë");
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        System.out.printf("%nFecha del sistema: %s%n", 
                         LocalDate.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy")));
        System.out.println();
    }
    
    private static void mostrarMenuPrincipal() {
        System.out.println("\n" + "‚ïê".repeat(50));
        System.out.println("               MEN√ö PRINCIPAL");
        System.out.println("‚ïê".repeat(50));
        System.out.println("1. üìö Gesti√≥n de Libros");
        System.out.println("2. üë• Gesti√≥n de Usuarios");
        System.out.println("3. üîÑ Realizar Pr√©stamo");
        System.out.println("4. üìä Generar Reportes");
        System.out.println("5. üìà Estad√≠sticas Globales");
        System.out.println("0. üö™ Salir del Sistema");
        System.out.println("‚ïê".repeat(50));
        System.out.print("Seleccione una opci√≥n: ");
    }
    
    private static int leerOpcionMenu() {
        try {
            String entrada = scanner.nextLine().trim();
            return Integer.parseInt(entrada);
        } catch (NumberFormatException e) {
            return -1; // Opci√≥n inv√°lida
        }
    }
    
    private static void gestionarLibros() {
        System.out.println("\nüîπ GESTI√ìN DE LIBROS üîπ");
        System.out.println("1. Agregar nuevo libro");
        System.out.println("2. Buscar libro");
        System.out.println("3. Listar todos los libros");
        System.out.print("Opci√≥n: ");
        
        int subOpcion = leerOpcionMenu();
        
        switch (subOpcion) {
            case 1:
                agregarNuevoLibro();
                break;
            case 2:
                buscarLibro();
                break;
            case 3:
                listarLibros();
                break;
            default:
                System.out.println("Opci√≥n inv√°lida en gesti√≥n de libros");
        }
    }
    
    private static void agregarNuevoLibro() {
        if (totalLibrosRegistrados >= CAPACIDAD_MAXIMA) {
            System.err.println("‚ùå Capacidad m√°xima alcanzada. No se pueden agregar m√°s libros.");
            return;
        }
        
        System.out.println("\n--- AGREGAR NUEVO LIBRO ---");
        System.out.print("T√≠tulo: ");
        String titulo = scanner.nextLine().trim();
        
        System.out.print("Autor: ");
        String autor = scanner.nextLine().trim();
        
        System.out.print("ISBN (13 d√≠gitos): ");
        String isbn = scanner.nextLine().trim();
        
        System.out.print("A√±o de publicaci√≥n: ");
        int anioPublicacion = 0;
        try {
            anioPublicacion = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("‚ùå A√±o inv√°lido. Libro no agregado.");
            return;
        }
        
        // Validaciones usando conceptos de case sensitivity y strings
        if (titulo.isEmpty() || autor.isEmpty()) {
            System.err.println("‚ùå T√≠tulo y autor no pueden estar vac√≠os.");
            return;
        }
        
        if (!validarISBN(isbn)) {
            System.err.println("‚ùå ISBN inv√°lido. Debe tener 13 d√≠gitos num√©ricos.");
            return;
        }
        
        // Crear nuevo libro
        Libro nuevoLibro = new Libro(titulo, autor, isbn, anioPublicacion);
        inventarioLibros[totalLibrosRegistrados] = nuevoLibro;
        totalLibrosRegistrados++;
        
        System.out.printf("‚úÖ Libro agregado exitosamente. ID: %d%n", nuevoLibro.getId());
        System.out.printf("Total de libros en sistema: %d%n", totalLibrosRegistrados);
    }
    
    private static boolean validarISBN(String isbn) {
        // Implementaci√≥n de validaci√≥n usando conceptos de strings y case sensitivity
        if (isbn == null || isbn.length() != 13) {
            return false;
        }
        
        // Verificar que solo contenga d√≠gitos
        for (int i = 0; i < isbn.length(); i++) {
            char c = isbn.charAt(i);
            if (c < '0' || c > '9') {
                return false;
            }
        }
        return true;
    }
    
    private static void buscarLibro() {
        System.out.println("\n--- BUSCAR LIBRO ---");
        System.out.print("Ingrese t√©rmino de b√∫squeda (t√≠tulo o autor): ");
        String termino = scanner.nextLine().trim().toLowerCase();
        
        boolean encontrado = false;
        System.out.printf("%n%-5s | %-30s | %-25s | %-13s | %-6s%n", 
                         "ID", "T√çTULO", "AUTOR", "ISBN", "A√ëO");
        System.out.println("‚îÄ".repeat(85));
        
        for (int i = 0; i < totalLibrosRegistrados; i++) {
            Libro libro = inventarioLibros[i];
            // Demostraci√≥n de case sensitivity en b√∫squedas
            if (libro.getTitulo().toLowerCase().contains(termino) || 
                libro.getAutor().toLowerCase().contains(termino)) {
                
                System.out.printf("%-5d | %-30s | %-25s | %-13s | %-6d%n",
                                libro.getId(),
                                libro.getTitulo(),
                                libro.getAutor(),
                                libro.getIsbn(),
                                libro.getAnioPublicacion());
                encontrado = true;
            }
        }
        
        if (!encontrado) {
            System.out.println("‚ùå No se encontraron libros con ese t√©rmino de b√∫squeda.");
        }
    }
    
    private static void listarLibros() {
        if (totalLibrosRegistrados == 0) {
            System.out.println("üìñ No hay libros registrados en el sistema.");
            return;
        }
        
        System.out.printf("%n=== CAT√ÅLOGO COMPLETO (%d libros) ===%n", totalLibrosRegistrados);
        System.out.printf("%-5s | %-35s | %-25s | %-6s%n", "ID", "T√çTULO", "AUTOR", "A√ëO");
        System.out.println("‚îÄ".repeat(80));
        
        for (int i = 0; i < totalLibrosRegistrados; i++) {
            Libro libro = inventarioLibros[i];
            System.out.printf("%-5d | %-35s | %-25s | %-6d%n",
                            libro.getId(),
                            libro.getTitulo(),
                            libro.getAutor(),
                            libro.getAnioPublicacion());
        }
    }
    
    private static void gestionarUsuarios() {
        System.out.println("\nüë§ GESTI√ìN DE USUARIOS");
        System.out.printf("Usuarios registrados: %d%n", totalUsuariosRegistrados);
        // Implementaci√≥n simplificada
        System.out.println("Funcionalidad en desarrollo...");
    }
    
    private static void realizarPrestamo() {
        System.out.println("\nüìã REALIZAR PR√âSTAMO");
        // Implementaci√≥n simplificada
        System.out.println("Funcionalidad en desarrollo...");
    }
    
    private static void generarReportes() {
        System.out.println("\nüìä GENERAR REPORTES");
        
        // Reporte por d√©cada usando estructuras de control
        System.out.println("\n--- LIBROS POR D√âCADA ---");
        
        // Contadores por d√©cada
        int[] librosPorDecada = new int[10]; // 1950-2029
        String[] etiquetasDecadas = {
            "1950-1959", "1960-1969", "1970-1979", "1980-1989", "1990-1999",
            "2000-2009", "2010-2019", "2020-2029", "Otros", "Sin fecha"
        };
        
        for (int i = 0; i < totalLibrosRegistrados; i++) {
            int anio = inventarioLibros[i].getAnioPublicacion();
            
            if (anio >= 1950 && anio <= 2029) {
                int indice = (anio - 1950) / 10;
                if (indice < 8) {
                    librosPorDecada[indice]++;
                } else {
                    librosPorDecada[8]++; // Otros
                }
            } else {
                librosPorDecada[9]++; // Sin fecha v√°lida
            }
        }
        
        for (int i = 0; i < etiquetasDecadas.length; i++) {
            if (librosPorDecada[i] > 0) {
                System.out.printf("%-12s: %3d libro(s) %s%n", 
                                etiquetasDecadas[i], 
                                librosPorDecada[i],
                                "‚ñ†".repeat(librosPorDecada[i]));
            }
        }
    }
    
    // M√©todo est√°tico para mostrar estad√≠sticas globales
    private static void mostrarEstadisticasGlobales() {
        System.out.println("\nüìà ESTAD√çSTICAS GLOBALES DEL SISTEMA");
        System.out.println("‚ïê".repeat(60));
        System.out.printf("üèõÔ∏è  Biblioteca:           %s%n", NOMBRE_BIBLIOTECA);
        System.out.printf("üíæ  Versi√≥n del sistema:  %s%n", VERSION_SISTEMA);
        System.out.printf("üìö  Total libros:         %d / %d%n", totalLibrosRegistrados, CAPACIDAD_MAXIMA);
        System.out.printf("üë•  Total usuarios:       %d / %d%n", totalUsuariosRegistrados, CAPACIDAD_MAXIMA);
        System.out.printf("üìä  Ocupaci√≥n:            %.1f%%%n", 
                         ((double) totalLibrosRegistrados / CAPACIDAD_MAXIMA) * 100);
        System.out.printf("üóìÔ∏è  Fecha consulta:       %s%n", 
                         LocalDate.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")));
        System.out.println("‚ïê".repeat(60));
        
        if (totalLibrosRegistrados > 0) {
            System.out.println("\nüèÜ TOP D√âCADAS CON M√ÅS LIBROS:");
            generarReportes();
        }
    }
    
    private static void inicializarDatosDemo() {
        // Agregar algunos libros de demostraci√≥n
        inventarioLibros[0] = new Libro("Effective Java", "Joshua Bloch", "9780134685991", 2017);
        inventarioLibros[1] = new Libro("Clean Code", "Robert Martin", "9780132350884", 2008);
        inventarioLibros[2] = new Libro("Java: The Complete Reference", "Herbert Schildt", "9781260440235", 2020);
        inventarioLibros[3] = new Libro("Spring in Action", "Craig Walls", "9781617294945", 2018);
        inventarioLibros[4] = new Libro("Head First Java", "Kathy Sierra", "9780596009205", 2005);
        
        totalLibrosRegistrados = 5;
        
        System.out.printf("‚úÖ Sistema inicializado con %d libros de demostraci√≥n.%n", 
                         totalLibrosRegistrados);
    }
    
    private static void mostrarDespedida() {
        System.out.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.println("‚ïë                    ¬°Gracias por usar!                       ‚ïë");
        System.out.printf("‚ïë  %s%-54s  ‚ïë%n", "", NOMBRE_BIBLIOTECA);
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.println("‚ïë  Sistema desarrollado como proyecto integrador              ‚ïë");
        System.out.println("‚ïë  Aplicando conceptos fundamentales de Java 8                ‚ïë");
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.printf("‚ïë  üìä Estad√≠sticas de la sesi√≥n:                              ‚ïë%n");
        System.out.printf("‚ïë     ‚Ä¢ Libros registrados: %-8d                       ‚ïë%n", totalLibrosRegistrados);
        System.out.printf("‚ïë     ‚Ä¢ Usuarios registrados: %-6d                       ‚ïë%n", totalUsuariosRegistrados);
        System.out.println("‚ïë                                                              ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        
        System.out.printf("%nüïê Sesi√≥n finalizada: %s%n", 
                         java.time.LocalDateTime.now().format(
                            DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")));
    }
}

// Clase para representar un libro (demostraci√≥n de variables de instancia)
class Libro {
    // Variable est√°tica - contador de libros creados
    private static int contadorLibros = 0;
    
    // Variables de instancia
    private int id;
    private String titulo;
    private String autor;
    private String isbn;
    private int anioPublicacion;
    private boolean prestado;
    
    // Constructor
    public Libro(String titulo, String autor, String isbn, int anioPublicacion) {
        contadorLibros++;
        this.id = contadorLibros;
        this.titulo = titulo;
        this.autor = autor;
        this.isbn = isbn;
        this.anioPublicacion = anioPublicacion;
        this.prestado = false;
    }
    
    // Getters y setters (demostraci√≥n de case sensitivity)
    public int getId() { return id; }
    public String getTitulo() { return titulo; }
    public String getAutor() { return autor; }
    public String getIsbn() { return isbn; }
    public int getAnioPublicacion() { return anioPublicacion; }
    public boolean isPrestado() { return prestado; }
    
    public void setPrestado(boolean prestado) {
        this.prestado = prestado;
    }
    
    // M√©todo para mostrar informaci√≥n completa
    public void mostrarInformacion() {
        System.out.printf("üìñ Libro ID: %d%n", id);
        System.out.printf("   T√≠tulo: %s%n", titulo);
        System.out.printf("   Autor: %s%n", autor);
        System.out.printf("   ISBN: %s%n", isbn);
        System.out.printf("   A√±o: %d%n", anioPublicacion);
        System.out.printf("   Estado: %s%n", prestado ? "Prestado" : "Disponible");
    }
    
    // M√©todo est√°tico
    public static int getTotalLibrosCreados() {
        return contadorLibros;
    }
}

// Clase para representar un usuario
class Usuario {
    private static int contadorUsuarios = 0;
    
    private int id;
    private String nombre;
    private String email;
    private String telefono;
    
    public Usuario(String nombre, String email, String telefono) {
        contadorUsuarios++;
        this.id = contadorUsuarios;
        this.nombre = nombre;
        this.email = email;
        this.telefono = telefono;
    }
    
    // Getters
    public int getId() { return id; }
    public String getNombre() { return nombre; }
    public String getEmail() { return email; }
    public String getTelefono() { return telefono; }
    
    public static int getTotalUsuarios() {
        return contadorUsuarios;
    }
}
```

### **üìã Conceptos aplicados en el proyecto:**

1. **‚úÖ El m√©todo main()**: Punto de entrada del programa con l√≥gica principal
2. **‚úÖ Estructura de clases**: Clases `Libro`, `Usuario` y `SistemaBiblioteca`
3. **‚úÖ System.out**: Uso extensivo de `println()`, `printf()` con formatos complejos
4. **‚úÖ Case Sensitivity**: Validaciones, m√©todos con nombres precisos, variables diferenciadas
5. **‚úÖ Variables est√°ticas vs instancia**: Contadores globales vs datos espec√≠ficos de objetos
6. **‚úÖ Strings inmutables**: Manipulaci√≥n de cadenas, b√∫squedas, validaciones
7. **‚úÖ Estructuras de control**: `while`, `switch`, `for`, `if-else` anidados
8. **‚úÖ Arrays**: Almacenamiento de libros y usuarios, reportes estad√≠sticos
9. **‚úÖ Tipos de datos**: Manejo de `int`, `String`, `boolean`, `double`
10. **‚úÖ Comentarios**: Documentaci√≥n clara del c√≥digo

### **üéØ Ejercicios de extensi√≥n:**

1. **Agregar funcionalidad de pr√©stamos**: Implementar sistema completo de pr√©stamos y devoluciones
2. **Validaciones avanzadas**: Email, tel√©fono, fechas de vencimiento
3. **Reportes adicionales**: Por autor, por a√±o, libros m√°s prestados
4. **Persistencia**: Guardar y cargar datos de archivos
5. **Interfaz mejorada**: Colores en consola, men√∫s m√°s intuitivos

---

## üè≠ **CONCEPTOS AVANZADOS: EJEMPLOS DE C√ìDIGO REAL DE PRODUCCI√ìN**

### üìä **AN√ÅLISIS DE C√ìDIGO EMPRESARIAL REAL**

Los siguientes ejemplos provienen de un sistema real de ingenier√≠a para dise√±o de transformadores el√©ctricos. Analicemos c√≥mo se aplican los conceptos fundamentales en software de producci√≥n:

---

### üîß **CONCEPTO AVANZADO 1: INTERFACES Y MULTIHILOS**

#### **üéØ Implementaci√≥n de Interfaces:**
```java
// Del archivo Funciones.java - Implementaci√≥n real de Runnable
public class Funciones implements Runnable {
    // Variables de instancia para el hilo
    String hora, minutos, segundos, ampm;
    Calendar calendario;
    
    // Implementaci√≥n obligatoria del m√©todo run()
    @Override
    public void run() {
        // L√≥gica que se ejecuta en el hilo separado
        // Actualizaci√≥n de reloj en tiempo real
        while (true) {
            calcula();  // Actualizar hora
            reloj();    // Mostrar en interfaz
            try {
                Thread.sleep(1000);  // Pausa de 1 segundo
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
```

**üí° Explicaci√≥n:**
- **Interface `Runnable`**: Contrato que obliga a implementar el m√©todo `run()`
- **Multihilos**: Permite ejecutar el reloj en paralelo sin bloquear la interfaz
- **Implementaci√≥n real**: El sistema actualiza varios relojes simult√°neamente

---

### üóÉÔ∏è **CONCEPTO AVANZADO 2: BASES DE DATOS Y MANEJO DE EXCEPCIONES**

#### **üéØ Consultas a Base de Datos con Manejo Robusto:**
```java
// Del archivo Consultas.java - M√©todo real para cargar usuarios
public static void llenarUsuarios() {
    ServiciosBD.ConsultaGenereal("idusuario,login,contra,email,nombre,apellido,rol,ruta_firma", 
                                "usuarios", "Order By Idusuario","");
    DefaultTableModel modelo = new DefaultTableModel();
    Administracion.jtQuery.setModel(modelo);
    
    try {
        ResultSetMetaData rsMd = ServiciosBD.resultado.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        
        // Configurar cabeceras de tabla din√°micamente
        for (int i = 1; i <= cantidadColumnas; i++) {
            modelo.addColumn(rsMd.getColumnLabel(i));
        }
        
        // Llenar datos fila por fila
        while (ServiciosBD.resultado.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int i = 0; i < cantidadColumnas; i++) {
                fila[i] = ServiciosBD.resultado.getObject(i+1);
            }
            modelo.addRow(fila);
        }
        ServiciosBD.resultado.close();
        
    } catch (SQLException ex) {
        // Logging profesional del error
        log.error(usuarioLogin.getNombre() + usuarioLogin.getApellido() + ex);
        
        // Notificaci√≥n al usuario
        JOptionPane.showMessageDialog(null, ex, "Error en la consulta llenar usuarios", 
                                    JOptionPane.WARNING_MESSAGE);
        
        // Env√≠o autom√°tico de reporte de error
        Email.Lanzar("Consultas.LlenarUsuarios", ex.toString(), 0);
    }
}
```

**üí° Conceptos Aplicados:**
- **Excepciones**: Manejo profesional con `try-catch`
- **Logging**: Registro de errores para debugging
- **Interfaz Gr√°fica**: Integraci√≥n con tablas Swing
- **Base de Datos**: Consultas SQL con metadatos din√°micos

---

### üìê **CONCEPTO AVANZADO 3: C√ÅLCULOS DE INGENIER√çA CON VALIDACI√ìN**

#### **üéØ M√©todo Complejo de C√°lculo Real:**
```java
// Del archivo Consultas.java - C√°lculo de aislamientos el√©ctricos
public static void CapAislamientos(Double emin, Double vc2, String TipoPapel, int nReferencias) {        
    // Query SQL compleja para c√°lculos de ingenier√≠a
    ServiciosBD.ConsultaGenereal(
        "CAPACIDAD_AISLAMIENTOS_J.*," +
        "(CP08*DPP0075+CP13*DPP013+CP18*DPP018+CP25*DPP025+" +
        "CDPE13*DPE013+CDPE15*DPE015+CDPE20*DPE020+" +
        "CDPE25*DPE025+CDPE30*DPE030) as COSTO",
        
        "CAPACIDAD_AISLAMIENTOS_J," +
        "(select * from(select items_unoe" + DatosFactores.CostoMes + ".ITEM as item," +
        "espesor,proyeccion from items_unoe" + DatosFactores.CostoMes + "," +
        "kits_papel_epox where kits_papel_epox.item=items_unoe" + DatosFactores.CostoMes + 
        ".item) PIVOT(avg(proyeccion*espesor) for item in (" + 
        (TipoPapel.contains("TuFlex") ? "38074" : "13152") + " as CP08," +
        "514 as CP13,515 as CP18,516 as CP25," +
        "51890 as CDPE13,51890 as CDPE15,51890 as CDPE20," +
        "51892 as CDPE25,51893 as CDPE30)))",
        
        "WHERE cap >= " + vc2 + " AND tipo = '" + TipoPapel + "' AND DPP0038 = 0 " +
        "AND DPP0050 = 0 AND DPE013 = 0 " +
        (!Aislamientos.habilitarPapel013 ? "AND DPP013 = 0" : "") + 
        " AND ep >= " + emin + " AND NREFERENCIAS <= " + nReferencias + 
        " ORDER by ep, cap desc, costo", "");
}
```

**üí° Conceptos Aplicados:**
- **Par√°metros m√∫ltiples**: M√©todo con 4 par√°metros de diferentes tipos
- **Condicionales complejas**: Uso de operador ternario en SQL
- **Concatenaci√≥n de strings**: Construcci√≥n din√°mica de consultas
- **Validaciones**: Filtros basados en variables de estado
- **Ingenier√≠a real**: C√°lculos de capacidad de aislamiento el√©ctrico

---

### üìã **CONCEPTO AVANZADO 4: MANEJO DE METADATOS Y TABLAS DIN√ÅMICAS**

#### **üéØ Construcci√≥n Din√°mica de Interfaces:**
```java
// Del archivo Consultas.java - Tabla din√°mica de prec√°lculos
public static void TablaPrecalculo() {
    // Query con formateo de moneda y campos condicionales
    ServiciosBD.ConsultaGenereal(
        "IDD,TO_CHAR(CEVF,'$999,999,999.00') as CEVF,PCU,PO,PT,TCC,IO,RIO,LAMINA," +
        (DatosEntrada.TCons == 5 || DatosEntrada.TCons == 6 ? "DN,AC" : "AI,BIF") + "," +
        "BFO,N2,HC2,EC2,SC2,AWG1,HTB,DIT,DAV,EFICIENCIA," +
        "TO_CHAR(CCF,'$999,999,999.00') as CCF,ac,bc,gtotal,at,bt,ht,SC", 
        "Precalculo", "Order By CEVF", "");
        
    precalculo = new DefaultTableModel();
    Precalculos.jTable1.setModel(precalculo);
    Precalculos.jTable1.setRowSorter(new TableRowSorter(precalculo));
    
    try {
        ResultSetMetaData rsMd = ServiciosBD.resultado.getMetaData();
        int cantidadColumnas = rsMd.getColumnCount();
        
        // Cabeceras din√°micas
        for (int i = 1; i <= cantidadColumnas; i++) {
            precalculo.addColumn(rsMd.getColumnLabel(i));
        }
        
        // Procesamiento condicional por columna
        while (ServiciosBD.resultado.next()) {
            Object[] fila = new Object[cantidadColumnas];
            for (int i = 0; i < cantidadColumnas; i++) {
                switch (i) {
                    case 0:  // ID
                    case 2:  // PCU 
                    case 3:  // PO
                    case 4:  // PT
                    case 11: // Otros campos num√©ricos
                        // Procesamiento espec√≠fico para n√∫meros
                        fila[i] = ServiciosBD.resultado.getObject(i + 1);
                        break;
                    default:
                        // Procesamiento gen√©rico
                        fila[i] = ServiciosBD.resultado.getString(i + 1);
                }
            }
            precalculo.addRow(fila);
        }
    } catch (SQLException ex) {
        // Manejo de excepciones...
    }
}
```

**üí° Conceptos Aplicados:**
- **Metadatos**: Uso de `ResultSetMetaData` para estructura din√°mica
- **Formateo SQL**: `TO_CHAR` para formato de moneda
- **Condicionales**: Campos diferentes seg√∫n tipo de consulta
- **Switch statements**: Procesamiento espec√≠fico por tipo de columna
- **Ordenamiento**: Integraci√≥n con `TableRowSorter` para interfaz

---

### ‚ö° **CONCEPTO AVANZADO 5: VARIABLES EST√ÅTICAS COMPLEJAS**

#### **üéØ Sistema de Estado Global:**
```java
// Del archivo Funciones.java - Variables est√°ticas del sistema real
public class Funciones implements Runnable {
    // Control de estado de ventanas
    public static int bandera, bandera1, bandera2, bandera3, bandera4, bandera5, 
                     bandera6, bandera7, bandera8, BanderaVemergente, IndexVemergente, band = 0;
    
    // Configuraci√≥n del sistema
    public static String Ip = "", Equipo = "";
    public static File Archivo = null;
    public static int Tamano;
    
    // Matrices de datos t√©cnicos
    public static double[][] VpTaps;  // Datos de taps de voltaje
    public static String Dis[][];     // Dise√±os disponibles
    public static double[][] ai_bi_Solid;  // Coeficientes s√≥lidos
    
    // Constantes de ingenier√≠a (f√≥rmulas espec√≠ficas)
    public static double C1wrwct = 7.2661 * Math.pow(10, -5);
    public static double C2wrwct = -2.9651 * Math.pow(10, -4);
    public static double C3wrwct = 4.7827 * Math.pow(10, -5);
    public static double C4wrwct = -2.83954 * Math.pow(10, -4);
    public static double C1wco = 4.4357 * Math.pow(10, -5);
    public static double C2wco = -3.26986 * Math.pow(10, -4);
    
    // Variables de control de proceso
    public static boolean advEmbalaje = false, embalajeXestandar = false;
    public static boolean ULxEstandar = false, aceiteXestandar = false;
    
    // Hilos de ejecuci√≥n
    public static Thread h1;
    
    // Variables para c√°lculos espec√≠ficos
    public static double tcc = 0, XL = 0, r = 0;  // Regulaci√≥n en predise√±o
    public static double espirasAntesTapMedio = 0;
}
```

**üí° Conceptos Aplicados:**
- **Variables de estado**: Control global del flujo de aplicaci√≥n
- **Matrices multidimensionales**: Almacenamiento de datos t√©cnicos complejos
- **Constantes calculadas**: Valores de ingenier√≠a con `Math.pow()`
- **Referencias a objetos**: `File`, `Thread` como variables est√°ticas
- **Naming conventions**: Nombres descriptivos para dominio espec√≠fico

---

### üéØ **LECCIONES DE C√ìDIGO PROFESIONAL**

#### **‚úÖ Buenas Pr√°cticas Observadas:**

1. **Separaci√≥n de responsabilidades**:
   - `Funciones.java`: Utilidades generales
   - `Consultas.java`: Acceso a datos espec√≠fico

2. **Manejo robusto de errores**:
   - Try-catch espec√≠ficos por tipo de operaci√≥n
   - Logging detallado para debugging
   - Notificaciones autom√°ticas de errores

3. **Flexibilidad**:
   - Consultas SQL din√°micas
   - Interfaces que se adaptan a diferentes datos
   - Configuraciones mediante variables est√°ticas

4. **Documentaci√≥n profesional**:
   - JavaDoc completo con autor y versi√≥n
   - Comentarios explicativos en l√≥gica compleja
   - Nombres de variables autodescriptivos

#### **üîß Patrones de Dise√±o Aplicados:**

- **Singleton impl√≠cito**: Variables est√°ticas para estado global
- **Factory pattern**: Construcci√≥n din√°mica de tablas
- **Observer pattern**: Interfaces que reaccionan a cambios de datos
- **Thread pattern**: Ejecuci√≥n concurrente para interfaces responsivas

**Estos ejemplos demuestran c√≥mo los conceptos b√°sicos de Java se combinan para crear software empresarial robusto y funcional.**

---

## üîÑ **COMPARATIVA: DE LOS CONCEPTOS B√ÅSICOS AL C√ìDIGO PROFESIONAL**

### üìä **Evoluci√≥n del Conocimiento**

| Concepto B√°sico | Aplicaci√≥n en Producci√≥n | Ejemplo del Sistema Real |
|-----------------|-------------------------|--------------------------|
| **Variables simples** | **Estado global complejo** | `public static int bandera1, bandera2, bandera3...` |
| **M√©todos b√°sicos** | **APIs especializadas** | `CapAislamientos()`, `TablaPrecalculo()` |
| **System.out.println** | **Logging profesional** | `log.error()`, `Email.Lanzar()` |
| **If-else simple** | **Condicionales complejas** | `(DatosEntrada.TCons==5\|\|DatosEntrada.TCons==6?"DN,AC":"AI,BIF")` |
| **Arrays b√°sicos** | **Matrices multidimensionales** | `double[][] VpTaps`, `String Dis[][]` |
| **Strings concatenaci√≥n** | **Construcci√≥n din√°mica SQL** | Query SQL de 500+ caracteres |
| **Try-catch b√°sico** | **Manejo integral errores** | Logging + Notificaci√≥n + Email autom√°tico |

### üéØ **Progresi√≥n de Complejidad**

#### **üü¢ NIVEL B√ÅSICO (Conceptos 1-5):**
```java
// Lo que aprendes primero
public class MiClase {
    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }
}
```

#### **üü° NIVEL INTERMEDIO (Conceptos 6-10):**
```java
// Agregando l√≥gica y control
public class CalculadoraBasica {
    public static double sumar(double a, double b) {
        return a + b;
    }
}
```

#### **üü† NIVEL AVANZADO (Conceptos 11-13):**
```java
// Manejo de excepciones y validaciones
public class ValidadorDatos {
    public static boolean validar(String input) {
        try {
            Double.parseDouble(input);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

#### **üî¥ NIVEL PROFESIONAL (C√≥digo Real de Producci√≥n):**
```java
// Sistema completo con m√∫ltiples responsabilidades
public class Funciones implements Runnable {
    public static void CapAislamientos(Double emin, Double vc2, String TipoPapel, int nReferencias) {
        // 20+ l√≠neas de SQL complejo
        // Manejo de metadatos din√°micos
        // Integraci√≥n con interfaces gr√°ficas
        // Sistema de logging y notificaciones
    }
}
```

### üöÄ **Camino de Aprendizaje Recomendado**

#### **Fase 1: Fundamentos (Semanas 1-2)**
1. ‚úÖ Dominar conceptos 1-5 del README
2. ‚úÖ Practicar con ejemplos b√°sicos
3. ‚úÖ Entender compilaci√≥n y ejecuci√≥n

#### **Fase 2: Estructuras (Semanas 3-4)**
1. üìñ Estudiar conceptos 6-10
2. üõ†Ô∏è Implementar calculadoras simples
3. üéØ Practicar arrays y strings

#### **Fase 3: Control Avanzado (Semanas 5-6)**
1. üìö Conceptos 11-13 + excepciones
2. üîß Crear validadores y utilidades
3. üß™ Testing y debugging

#### **Fase 4: C√≥digo Real (Semanas 7-8)**
1. üè≠ Analizar c√≥digo de `Funciones.java` y `Consultas.java`
2. üîç Entender patrones de dise√±o aplicados
3. üíº Implementar mini-proyectos similares

### üí° **Reflexiones Finales**

#### **üéì Lo que Aprendiste:**
- **Fundamentos s√≥lidos**: Base te√≥rica completa de Java 8
- **Ejemplos reales**: C√≥digo de producci√≥n aut√©ntico
- **Progresi√≥n natural**: Del "Hola Mundo" a sistemas empresariales
- **Buenas pr√°cticas**: Patrones observados en software real

#### **üöÄ Pr√≥ximos Pasos:**
- **Frameworks**: Spring, Hibernate, Maven
- **Bases de Datos**: JDBC, JPA, conexiones reales
- **Interfaces Gr√°ficas**: Swing avanzado, JavaFX
- **Arquitectura**: Patrones de dise√±o, clean code

#### **üèÜ Objetivo Cumplido:**
Has visto la **evoluci√≥n completa** desde conceptos b√°sicos hasta implementaciones profesionales. El c√≥digo de `Funciones.java` y `Consultas.java` no son ejercicios acad√©micos - son **herramientas reales** usadas en la industria para resolver **problemas complejos de ingenier√≠a**.

**¬°Ahora tienes las bases para construir software profesional en Java!**

---

### Pr√°ctica Adicional:
- [CodingBat Java](https://codingbat.com/java)
- [HackerRank Java](https://www.hackerrank.com/domains/java)
- [LeetCode](https://leetcode.com/)

---